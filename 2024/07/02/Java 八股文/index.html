<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 八股文 | 雪荷的博客</title><meta name="author" content="雪荷"><meta name="copyright" content="雪荷"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 八股文Java 基础基础概念与常识Java 语言的特点 简单易学 面向对象（封装、继承、多态） 安全性（Java语言提供了多种资源权限访问修饰符、限制程序直接访问操作系统资源） 可靠性（异常处理和自动内存管理机制） 跨平台性（依靠JVM，Java语言可以实现一次编译，处处运行的机制）  Java SE vs Java EE Java SE：Java编程语言的标准版，包含支持了应用程序开发">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 八股文">
<meta property="og:url" content="http://example.com/2024/07/02/Java%20%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="雪荷的博客">
<meta property="og:description" content="Java 八股文Java 基础基础概念与常识Java 语言的特点 简单易学 面向对象（封装、继承、多态） 安全性（Java语言提供了多种资源权限访问修饰符、限制程序直接访问操作系统资源） 可靠性（异常处理和自动内存管理机制） 跨平台性（依靠JVM，Java语言可以实现一次编译，处处运行的机制）  Java SE vs Java EE Java SE：Java编程语言的标准版，包含支持了应用程序开发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/post_1.png">
<meta property="article:published_time" content="2024-07-02T07:40:33.000Z">
<meta property="article:modified_time" content="2024-07-03T04:39:03.681Z">
<meta property="article:author" content="雪荷">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/post_1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/02/Java%20%E5%85%AB%E8%82%A1%E6%96%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 八股文',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-03 12:39:03'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/ava.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/post_1.png')"><nav id="nav"><span id="blog-info"><a href="/" title="雪荷的博客"><span class="site-name">雪荷的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-02T07:40:33.000Z" title="发表于 2024-07-02 15:40:33">2024-07-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-03T04:39:03.681Z" title="更新于 2024-07-03 12:39:03">2024-07-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 八股文"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('/img/post_1.png');"></div><article class="post-content" id="article-container"><h1 id="Java-八股文"><a href="#Java-八股文" class="headerlink" title="Java 八股文"></a>Java 八股文</h1><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h3><h4 id="Java-语言的特点"><a href="#Java-语言的特点" class="headerlink" title="Java 语言的特点"></a>Java 语言的特点</h4><ol>
<li>简单易学</li>
<li>面向对象（封装、继承、多态）</li>
<li>安全性（Java语言提供了多种资源权限访问修饰符、限制程序直接访问操作系统资源）</li>
<li>可靠性（异常处理和自动内存管理机制）</li>
<li>跨平台性（依靠JVM，Java语言可以实现一次编译，处处运行的机制）</li>
</ol>
<h4 id="Java-SE-vs-Java-EE"><a href="#Java-SE-vs-Java-EE" class="headerlink" title="Java SE vs Java EE"></a>Java SE vs Java EE</h4><ul>
<li>Java SE：Java编程语言的标准版，包含支持了应用程序开发和运行的核心类库和虚拟机等核心组件，用于构建桌面应用程序和简单的服务器应用程序。</li>
<li>Java EE：Java编程语言的企业版，包含支持了企业级应用程序的开发和部署规范，如Servlet、JSP、JDBC、JPA等，用于构建企业级应用程序和 Web 应用。</li>
</ul>
<h4 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h4><ul>
<li>JVM（Java virtual machine）：Java 虚拟机，是运行 Java 字节码的虚拟机，JVM对于不同的操作系统有特定的实现，以保证相同的字节码文件给出相同的结果。</li>
<li>JDK（Java Development Kit）：Java开发工具包。是提供开发者使用的Java SDK，能够创建和编译 Java 程序的开发套件。它不仅包含了 JRE ，还包含了编译 Java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控工具）、javap（反编译工具）等等。</li>
<li>JRE（Java Runtime Environment）：是 Java 运行环境。它是运行已编译 Java 程序所需所有内容的集合，其中包括 JVM 和 Java 基础类库。</li>
</ul>
<p><strong>总结</strong>：<em>也就是说，JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。而 JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。</em>如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p>
<h4 id="什么是字节码？采用字节码的好处？"><a href="#什么是字节码？采用字节码的好处？" class="headerlink" title="什么是字节码？采用字节码的好处？"></a>什么是字节码？采用字节码的好处？</h4><p>字节码就是 JVM 能够理解的代码（.class 后缀文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言采用字节码的方式在一定程度上解决了传统解释型语言运行慢的问题，同时还能达到一次编译处处运行的效果。</p>
<p><strong>Java 程序从源代码到运行的过程</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/02/27/Java%E5%9F%BA%E7%A1%80-%E5%85%AB%E8%82%A1%E6%96%87/java-code-to-machine-code.png"><img src="https://blog.hejiajun.icu/2024/02/27/Java%E5%9F%BA%E7%A1%80-%E5%85%AB%E8%82%A1%E6%96%87/java-code-to-machine-code.png" alt="Java程序转变为机器代码的过程"></a></p>
<h4 id="为什么说-Java-语言编译和解释并存？"><a href="#为什么说-Java-语言编译和解释并存？" class="headerlink" title="为什么说 Java 语言编译和解释并存？"></a>为什么说 Java 语言编译和解释并存？</h4><p>因为 Java 语言同时具有编译型语言和解释型语言的特性，简单来说执行 Java 程序过程中经历了编译阶段和解释阶段。因为 javac 将 Java 源代码编译为字节码文件，后通过 JVM 解释字节码文件和该平台的机器码。</p>
<h5 id="JIT-编译模式"><a href="#JIT-编译模式" class="headerlink" title="JIT 编译模式"></a>JIT 编译模式</h5><p>JIT 编译器将字节码转换为本地机器码，并缓存以提高程序的性能。这种编译技术允许 Java 程序在运行时达到接近本地编译程序的性能。</p>
<h4 id="AOT-有什么优点？为什么不全部使用-AOT？"><a href="#AOT-有什么优点？为什么不全部使用-AOT？" class="headerlink" title="AOT 有什么优点？为什么不全部使用 AOT？"></a>AOT 有什么优点？为什么不全部使用 AOT？</h4><h5 id="AOT-优点"><a href="#AOT-优点" class="headerlink" title="AOT 优点"></a>AOT 优点</h5><p>JDK 9 引入了新的编译模式 AOT（Ahead of Time Compilation）。它会在程序执行前将其编译成机器码，属于静态编译。AOT 在一定程度上避免了 JIT 在预热等方面的开销，提高 Java 程序的启动速度，避免预热时间长，而且 AOT 编译后的代码不易被反编译和修改，特别适合云原生场景。</p>
<h5 id="为什么不全部使用-AOT？"><a href="#为什么不全部使用-AOT？" class="headerlink" title="为什么不全部使用 AOT？"></a>为什么不全部使用 AOT？</h5><p>虽然 AOT 优点有很多且特别适合云原生场景，但是其无法支持 Java 的一些动态特性如 反射、动态代理、动态加载等。然而很多框架和库都用到了此特性，如果全部使用 AOT 就无法使用这些强大的框架和库了。</p>
<blockquote>
<p>举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是<code>.class</code>文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>
</blockquote>
<h4 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++ 的区别?"></a>Java 和 C++ 的区别?</h4><ol>
<li>Java 不提供指针直接访问内存，程序内存更安全</li>
<li>Java 仅支持单继承，C++支持多继承，但是 Java 可以通过接口实现多继承</li>
<li>Java 有内存管理垃圾回收机制，开发者无需手动释放无用内存</li>
<li>Java仅支持方法重载，C++支持方法和操作符重载</li>
</ol>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="Java-注解有几种形式"><a href="#Java-注解有几种形式" class="headerlink" title="Java 注解有几种形式"></a>Java 注解有几种形式</h4><ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释</li>
</ol>
<h4 id="标识符和关键字的区别是什么？"><a href="#标识符和关键字的区别是什么？" class="headerlink" title="标识符和关键字的区别是什么？"></a>标识符和关键字的区别是什么？</h4><ul>
<li>标识符就是名字</li>
<li>关键字是被语言赋予了特殊含义的标识符</li>
</ul>
<h4 id="Java-语言关键字有哪些？"><a href="#Java-语言关键字有哪些？" class="headerlink" title="Java 语言关键字有哪些？"></a>Java 语言关键字有哪些？</h4><table>
<thead>
<tr>
<th>分类</th>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类，方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td>enum</td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td>assert</td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li><code>default</code> 关键字既属于程序控制，也属于类、方法、变量修饰符、访问控制（添加 default 访问修饰符就会报错）</li>
<li>虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</li>
</ol>
</blockquote>
<h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4><ul>
<li>运算符在前面：先 +1 / -1，再使用</li>
<li>运算符在后面：先使用，后 +1 / -1</li>
</ul>
<h4 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h4><blockquote>
<p>移位运算符是最基本的运算符之一。移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// HashMap中的hash方法源码：</span><br><span class="line">static final int hash(Object key) {</span><br><span class="line">    int h;</span><br><span class="line">    // key.hashCode()：返回散列值也就是hashcode</span><br><span class="line">    // ^：按位异或</span><br><span class="line">    // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>在 Java 代码里使用 <code>&lt;&lt;</code>（左移）、 <code>&gt;&gt;</code>（带符号右移） 和<code>&gt;&gt;&gt;</code>（无符号右移）转换成的指令码运行起来会更高效些。</p>
<blockquote>
<ul>
<li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li>
<li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li>
<li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li>
</ul>
<p>由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。</p>
<p>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p>
</blockquote>
<h5 id="如果移位的位数超过数值所占有的位数会怎样？"><a href="#如果移位的位数超过数值所占有的位数会怎样？" class="headerlink" title="如果移位的位数超过数值所占有的位数会怎样？"></a>如果移位的位数超过数值所占有的位数会怎样？</h5><p>当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p>
<p>也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x &gt;&gt;&gt;42</code>等同于<code>x &gt;&gt;&gt; 10</code>。</p>
<h4 id="continue、break-和-return-的区别是什么？"><a href="#continue、break-和-return-的区别是什么？" class="headerlink" title="continue、break 和 return 的区别是什么？"></a>continue、break 和 return 的区别是什么？</h4><ol>
<li><p><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</p>
</li>
<li><p><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</p>
</li>
<li><pre><code>return
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   用于跳出所在方法，结束该方法的运行</span><br><span class="line"></span><br><span class="line">   - `return;`：直接使用 return 结束方法执行，用于没有返回值函数的方法</span><br><span class="line">   - `return value;`：返回一个特定值，用于有返回值函数的方法</span><br><span class="line"></span><br><span class="line">#### 基本数据类型</span><br><span class="line"></span><br><span class="line">Java 中一共有8中基本数据类型：</span><br><span class="line"></span><br><span class="line">- 6 种数字类型：</span><br><span class="line">  - 4 种整数型：`byte`、`short`、`int`、`long`</span><br><span class="line">  - 2 种浮点型：`float`、`double`</span><br><span class="line">- 1 种字符类型：`char`</span><br><span class="line">- 1 种布尔型：`boolean`。</span><br><span class="line"></span><br><span class="line">## Spring 框架篇</span><br><span class="line"></span><br><span class="line">### 基础</span><br><span class="line"></span><br><span class="line">#### Spring 是什么？特性？有哪些模块？</span><br><span class="line"></span><br><span class="line">Spring 是一个轻量级、非侵入式的控制反转（IOC）和面向切面（AOP）编程的框架。</span><br><span class="line"></span><br><span class="line">##### Spring 特性</span><br><span class="line"></span><br><span class="line">1. IOC 和 DI 支持</span><br><span class="line">2. AOP 编程支持</span><br><span class="line">3. 声明式事务支持</span><br><span class="line">4. 快捷测试支持</span><br><span class="line">5. 快速集成功能</span><br><span class="line">6. 复杂 API 模块封装</span><br><span class="line"></span><br><span class="line">##### Spring 有哪些模块？</span><br><span class="line"></span><br><span class="line">[![Spring模块划分](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-bb7c13ea-3174-4b32-84b8-821849ddc377.png)](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-bb7c13ea-3174-4b32-84b8-821849ddc377.png)</span><br><span class="line"></span><br><span class="line">1. Spring Core：Spring 核心和基础部分，提供 IOC 和 DI 特性</span><br><span class="line">2. Spring Context：Spring 上下文容器，是 BeanFactory 功能加强的一个子接口</span><br><span class="line">3. Spring Web：提供 Web 应用开发</span><br><span class="line">4. Spring MVC：它针对 Web 应用中 MVC 思想的实现</span><br><span class="line">5. Spring DAO：提供对 JDBC 抽象层，简化了 JDBC 编码</span><br><span class="line">6. Spring ORM：整合了流行的 ORM 框架，如 Spring + Hibernate、Spring + iBatis、Spring + JDO</span><br><span class="line">7. Spring AOP：面向切面编程</span><br><span class="line"></span><br><span class="line">#### Spring 常用注解</span><br><span class="line"></span><br><span class="line">[![Spring常用注解](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-8d0a1518-a425-4887-9735-45321095d927.png)](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-8d0a1518-a425-4887-9735-45321095d927.png)</span><br><span class="line"></span><br><span class="line">##### Web：</span><br><span class="line"></span><br><span class="line">##### 容器：</span><br><span class="line"></span><br><span class="line">- @Component：声明此类是一个组件，成为 Spring 管理的 Bean，由 Spring 指定和管理其初始化和生命周期。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象</span><br><span class="line">- @Service：应用在 service 层，结合了 @Component注解</span><br><span class="line">- @Respository：应用在 dao 层，结合了 @Component注解</span><br><span class="line">- @Autowired：Spring 提供的工具（由 Spring 依赖注入工具 BeanPostProcessor、BeanFactoryPostProcessor 自动注入）</span><br><span class="line">- @Qualifier：</span><br><span class="line">- @Configuration：声明当前类为配置类，相当于 Spring 配置的 xml 文件</span><br><span class="line">- @Value：通常与 @Autowired 注解一起使用，当出现了两个类型一样的 Bean，通过此注解声明要使用 Bean 的名称以选择想用的 Bean</span><br><span class="line">- @Bean：</span><br><span class="line">- @Scope：指定采用什么模式去创建 Bean（前提有 @Bean），其设置类型包括：Singleton、Prototype、Request、Session、GlobalSession</span><br><span class="line"></span><br><span class="line">##### AOP：</span><br><span class="line"></span><br><span class="line">@Aspect：声明一个切面（类上），使用@After、@Before、@Around 定义建言（advice），可直接将拦截规则（切点）作为参数。</span><br><span class="line"></span><br><span class="line">- @After：方法执行之后执行（方法上）</span><br><span class="line">- @Before：方法执行之前执行（方法上）</span><br><span class="line">- @Around：方法执行之前和之后执行（方法上）</span><br><span class="line">- @PointCut：声明切点，在配置类上添加 @EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 的代理支持</span><br><span class="line"></span><br><span class="line">##### 事务：</span><br><span class="line"></span><br><span class="line">@Transactional：在要开启事务的方法上添加此注解即可开启声明式事务</span><br><span class="line"></span><br><span class="line">#### Spring 中用了哪些设计模式</span><br><span class="line"></span><br><span class="line">1. 工厂模式：Spring 本身就是一个巨大的工厂，通过 BeanFactory、ApplicationContext 创建 Bean 对象</span><br><span class="line">2. 代理模式：Spring AOP 就是通过代理模式实现的，分为动态代理和静态代理</span><br><span class="line">3. 单例模式：Spring 中的 Bean 默认都是单例的，便于管理</span><br><span class="line">4. 模板模式：Spring 中 JbbcTemplate、RestTemplate 等以 Template 结果的对数据库、网络操作的模板类，都用到了模板模式</span><br><span class="line">5. 观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用</span><br><span class="line">6. 策略模式：Spring 中有一个 Resource 接口，它的不同实现类会根据不同的策略去访问资源</span><br><span class="line">7. 适配器模式：Spring AOP 的增强和通知使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller</span><br><span class="line"></span><br><span class="line">### IoC</span><br><span class="line"></span><br><span class="line">#### 什么是 IoC？什么是 DI？</span><br><span class="line"></span><br><span class="line">- IoC 即控制反转，是一种设计思想，就是由容器控制对象的生命周期和对象之间的关系。（控制对象的生命周期不再是引用它的对象而是容器，将对象的控制权由程序员转变为 Spring 框架）</span><br><span class="line">- DI 是实现 IoC 的一种方式，通过容器注入对象之间的依赖关系，而不是在对象内部自行创建依赖对象。</span><br><span class="line"></span><br><span class="line">##### 依赖注入的 4 种实现方式</span><br><span class="line"></span><br><span class="line">1. 接口注入</span><br><span class="line">2. 构造方法注入</span><br><span class="line">3. 注解注入</span><br><span class="line">4. 字段注入</span><br><span class="line"></span><br><span class="line">#### </span><br><span class="line"></span><br><span class="line">#### Spring IOC 的实现机制</span><br><span class="line"></span><br><span class="line">#### @Component 和 @Bean 的区别？</span><br><span class="line"></span><br><span class="line">- @Component 作用于类上，@Bean作用于方法上</span><br><span class="line">- @Component 通过类路径扫描来自动侦测和自动装配到 Spring 容器中，而 @Bean 是我们在某个方法上添加此注解以定义和产生这个 Bean，告诉 Spring 这是某个类的实例</span><br><span class="line">- @Bean 比 @Component 自定义性更强（更灵活），比如我们引入第三方库中的类时只能通过 @Bean 来注册</span><br><span class="line"></span><br><span class="line">### </span><br><span class="line"></span><br><span class="line">#### @Autowired 和 @Resource 的区别</span><br><span class="line"></span><br><span class="line">- @Autowired 属于 Spring 内置的注解，默认注入方式为 byType，但是可以通过 @Qualifier 注解显式指明要注入 Bean 的名称</span><br><span class="line">- @Resource 属于 JDK 注解，默认注入方式为 byName，如果无法通过名称找到对应的 Bean，注入方式会变为 byType</span><br><span class="line">- @Autowired 支持在构造方法、方法、字段和参数上使用，而 @Resource 仅支持在字段和方法上使用</span><br><span class="line"></span><br><span class="line">#### Bean 的作用域有哪些？</span><br><span class="line"></span><br><span class="line">- singleton：IoC 容器中只有唯一的 bean 实例。（Spring 中的 bean 默认都是单例的）</span><br><span class="line">- prototype：每次获取都会创建一个新的 bean</span><br><span class="line">- request（仅 Web 应用可用）：每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效</span><br><span class="line">- session（仅 Web 应用可用）：每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效</span><br><span class="line">- application/global-session（仅 Web 应用可用）：每个 web 应用在启动时创建一个 bean（应用 bean），该 bean 仅在当前应用启动时间内有效</span><br><span class="line">- websocket（仅 Web 应用可用）：每一次 websocket 会话产生一个新的的 bean</span><br><span class="line"></span><br><span class="line">#### Bean 是线程安全的吗？</span><br><span class="line"></span><br><span class="line">Spring 框架中的 Bean 是否安全取决于其作用于和状态。</span><br><span class="line"></span><br><span class="line">以 singleton 和 prototype 两种作用域为例，prototype 作用域不存在线程安全问题，因为每次获取都会创建一个新的 Bean。</span><br><span class="line"></span><br><span class="line">而有状态的 bean（包含可变成员变量的对象） 存在线程安全问题，反之不存在线程安全问题。</span><br><span class="line"></span><br><span class="line">**常见有两种解决有状态 bean 的线程安全问题的方法：**</span><br><span class="line"></span><br><span class="line">1. 在 Bean 中尽量避免定义可变的成员变量</span><br><span class="line">2. 在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐）</span><br><span class="line"></span><br><span class="line">#### Bean 的生命周期</span><br><span class="line"></span><br><span class="line">1. **实例化（Instantiation）：** 在这个阶段，Spring 容器根据配置信息创建 Bean 的实例。通常情况下，Spring 使用反射机制来实例化 Bean，但也可以通过工厂方法或其他方式创建 Bean 实例。</span><br><span class="line"></span><br><span class="line">2. **设置属性（Population）：** 在实例化后，Spring 容器会通过依赖注入或其他方式为 Bean 设置属性，包括基本类型属性、引用类型属性以及其他配置属性。</span><br><span class="line"></span><br><span class="line">3. 初始化（Initialization）：</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   初始化阶段是 Bean 生命周期中的关键阶段，包括以下两个步骤：</span><br><span class="line"></span><br><span class="line">   - **Bean 初始化方法调用（Initialization callback）：** 在这个步骤中，Spring 调用 Bean 的初始化方法，可以通过配置 XML、注解或接口来指定初始化方法。常用的初始化方法包括 `@PostConstruct` 注解、`InitializingBean` 接口的 `afterPropertiesSet()` 方法以及自定义的初始化方法。</span><br><span class="line">   - **BeanPostProcessor 处理（BeanPostProcessor callback）：** 在初始化方法调用之前和之后，Spring 容器会调用注册的 `BeanPostProcessor` 实现类对 Bean 进行处理。`BeanPostProcessor` 接口提供了 `postProcessBeforeInitialization()` 和 `postProcessAfterInitialization()` 两个方法，允许开发者在 Bean 初始化前后进行一些自定义的处理逻辑，如增强、代理等。</span><br><span class="line"></span><br><span class="line">4. **使用（In Use）：** 在初始化完成后，Bean 就处于可用状态，可以被其他 Bean 或应用程序组件使用。</span><br><span class="line"></span><br><span class="line">5. 销毁（Destruction）：</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   当应用程序关闭或者不再需要某个 Bean 时，Spring 容器会执行 Bean 的销毁操作。销毁阶段包括以下两个步骤：</span><br><span class="line"></span><br><span class="line">   - **Bean 销毁方法调用（Destruction callback）：** 类似于初始化方法，在 Bean 销毁前，Spring 容器会调用 Bean 的销毁方法，可以通过配置 XML、注解或接口来指定销毁方法。常用的销毁方法包括 `@PreDestroy` 注解、`DisposableBean` 接口的 `destroy()` 方法以及自定义的销毁方法。</span><br><span class="line">   - **BeanPostProcessor 处理（BeanPostProcessor callback）：** 在销毁方法调用之前和之后，Spring 容器同样会调用注册的 `BeanPostProcessor` 实现类对 Bean 进行处理，允许开发者在销毁前后进行一些自定义的处理逻辑。</span><br><span class="line"></span><br><span class="line">#### Spring 怎么解决循环依赖？</span><br><span class="line"></span><br><span class="line">&gt; 循环依赖仅发生在 singleton 作用域的 bean 之间，如果是 prototype 作用域的 bean 就会抛异常</span><br><span class="line"></span><br><span class="line">Bean 的初始化步骤：</span><br><span class="line"></span><br><span class="line">[![三分恶面渣逆袭：Bean初始化步骤](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-867066f1-49d1-4e57-94f9-4c66a3a8797e.png)](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-867066f1-49d1-4e57-94f9-4c66a3a8797e.png)</span><br><span class="line"></span><br><span class="line">1. **实例化 Bean：** 当容器初始化 Bean 的时候，首先会实例化 Bean，但还未进行属性注入。</span><br><span class="line"></span><br><span class="line">2. **属性注入：** 在实例化 Bean 后，Spring 容器会将 Bean 的引用注入到其他 Bean 的属性中。</span><br><span class="line"></span><br><span class="line">3. 解决循环依赖：</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   当容器在注入属性时发现循环依赖时，Spring 会采取以下步骤来解决循环依赖：</span><br><span class="line"></span><br><span class="line">   - **提前暴露（Early Reference）：** Spring 将正在创建的 Bean 提前暴露给第三级缓存，以便其他 Bean 可以提前引用。这样，即使 Bean 还未完全创建完成，其他 Bean 也可以获取到对它的引用。</span><br><span class="line">   - **使用代理（Proxy）：** 当发现循环依赖时，Spring 会创建一个代理对象，代替真正的 Bean 对象注入到其他 Bean 中。这个代理对象负责延迟获取真正的 Bean 对象，从而打破循环依赖。</span><br><span class="line">   - **后处理器处理（Post-processing）：** Spring 使用 BeanPostProcessor 后处理器对 Bean 进行处理，确保循环依赖问题得到解决。后处理器会在 Bean 的初始化前后进行一些额外的处理，以确保 Bean 的正确创建和初始化。</span><br><span class="line"></span><br><span class="line">##### 为什么要三级缓存？二级不行吗？</span><br><span class="line"></span><br><span class="line">不行，主要是为了生成**代理对象**</span><br><span class="line"></span><br><span class="line">#### @Autowired 的实现原理？</span><br><span class="line"></span><br><span class="line">通过后置处理器：AutowiredAnnotationBeanPostProcessor 完成的。</span><br><span class="line"></span><br><span class="line">- Spring 在创建 bean 的过程中，最终会调用到 doCreateBean()方法，在 doCreateBean()方法中会调用 populateBean()方法，来为 bean 进行属性填充，完成自动装配等工作。</span><br><span class="line">- 在 populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行 return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到 AutowiredAnnotationBeanPostProcessor 的 postProcessPropertyValues()方法，在该方法中就会进行@Autowired 注解的解析，然后实现自动装配。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
JAVA
/**
</code></pre>
</li>
</ol>
<ul>
<li>属性赋值<br>**/<br>protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {<br>    //…………<br>    if (hasInstAwareBpps) {<br>        if (pvs == null) {<br>            pvs = mbd.getPropertyValues();<br>        }<br><br>        PropertyValues pvsToUse;<br>        for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {<br>            InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();<br>            pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);<br>            if (pvsToUse == null) {<br>                if (filteredPds == null) {<br>                    filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>                }<br>                //执行后处理器，填充属性，完成自动装配<br>                //调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法<br>                pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);<br>                if (pvsToUse == null) {<br>                    return;<br>                }<br>            }<br>        }<br>    }<br>   //…………<br>}</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- postProcessorPropertyValues()方法的源码如下，在该方法中，会先调用 findAutowiringMetadata()方法解析出 bean 中带有@Autowired 注解、@Inject 和@Value 注解的属性和方法。然后调用 metadata.inject()方法，进行属性填充。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>JAVA<br>public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {<br>    //@Autowired注解、@Inject和@Value注解的属性和方法<br>    InjectionMetadata metadata = this.findAutowiringMetadata(beanName, bean.getClass(), pvs);</p>
<pre><code>try {
    //属性填充
    metadata.inject(bean, beanName, pvs);
    return pvs;
} catch (BeanCreationException var6) {
    throw var6;
} catch (Throwable var7) {
    throw new BeanCreationException(beanName, "Injection of autowired dependencies failed", var7);
}
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### AOP</span><br><span class="line"></span><br><span class="line">简单来说，就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加清爽。</span><br><span class="line"></span><br><span class="line">AOP 的核心其实就是**动态代理**，可以使用 JDK 的动态代理，也可以使用 CGLIB 代理</span><br><span class="line"></span><br><span class="line">**AOP 有哪些核心概念？**</span><br><span class="line"></span><br><span class="line">- **切面**（Aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象</span><br><span class="line">- **连接点**（Join Point）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中，连接点指的是被拦截到的方法，实际上连接点还可以是字段或者构造方法</span><br><span class="line">- **切点**（Pointcut）：对连接点进行拦截的定位</span><br><span class="line">- **通知**（Advice）：指拦截到连接点之后要执行的代码，也可以称作**增强**</span><br><span class="line">- **目标对象** （Target）：代理的目标对象</span><br><span class="line">- **引介**（introduction）：一种特殊的增强，可以动态地为类添加一些属性和方法</span><br><span class="line">- **织入**（Weabing）：织入是将增强添加到目标类的具体连接点上的过程。</span><br><span class="line">- 可以分为 3 种类型的织入：</span><br><span class="line"></span><br><span class="line">①、编译期织入：切面在目标类编译时被织入。</span><br><span class="line"></span><br><span class="line">②、类加载期织入：切面在目标类加载到 JVM 时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。</span><br><span class="line"></span><br><span class="line">③、运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。Spring AOP 就是以这种方式织入切面。</span><br><span class="line"></span><br><span class="line">AOP 一般有 5 中环绕方式：</span><br><span class="line"></span><br><span class="line">- @Before</span><br><span class="line">- @AfterReturning</span><br><span class="line">- @AfterThrowing</span><br><span class="line">- @After</span><br><span class="line">- @Around</span><br><span class="line"></span><br><span class="line">#### JDK 动态代理和 CGLib 代理</span><br><span class="line"></span><br><span class="line">##### JDK 动态代理</span><br><span class="line"></span><br><span class="line">1. 基于接口：JDK 动态代理要求目标对象必须实现一个或多个接口。代理对象并非继承目标对象而是实现了和目标对象一样的接口</span><br><span class="line">2. 使用 InvocationHandler：在调用代理对象的任何方法时都会被转发到 invocationHandler 实例的 invoke 方法。可以在这个 invoke 方法中定义拦截逻辑</span><br><span class="line">3. 基于 Proxy：Proxy 利用 InvocationHandler 动态创建一个符合目标类实现的接口实例，生成目标类的代理对象</span><br><span class="line"></span><br><span class="line">##### CGLib 动态代理</span><br><span class="line"></span><br><span class="line">1. 基于继承：CGLIb 通过生成目标类的子类创建代理对象，并在子类中覆盖非 final 方法。</span><br><span class="line">2. 基于 ASM：ASM 是一个Java 字节操作和分析框架，CGLIB 通过它读取并修改目标类的字节码来生成新的类。其在运行时动态生成一个被代理的子类，并在子类中覆盖父类方法，通过方法拦截技术插入增强代码。</span><br><span class="line"></span><br><span class="line">#### Spring AOP 和 AspectJ AOP 有什么区别？</span><br><span class="line"></span><br><span class="line">- Spring AOP 属于运行时增强，而 AspectJ AOP 属于编译时增强</span><br><span class="line">- Spring AOP 基于动态代理实现，AspectJ AOP 基于字节码操作</span><br><span class="line"></span><br><span class="line">### 事务</span><br><span class="line"></span><br><span class="line">#### Spring 事务的种类？</span><br><span class="line"></span><br><span class="line">Spring 事务分为声明式事务和编程式事务两种。</span><br><span class="line"></span><br><span class="line">##### 编程式事务</span><br><span class="line"></span><br><span class="line">编程式事务可以使用 TransactionTemplate 和 PlatformTransactionManager 来实现，需要显式执行事务。允许我们在代码中直接控制事务的边界，通过编程方式明确指定事务的开始、提交和回滚。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>JAVA<br>public class AccountService {<br>    private TransactionTemplate transactionTemplate;</p>
<pre><code>public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
    this.transactionTemplate = transactionTemplate;
}

public void transfer(final String out, final String in, final Double money) {
    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus status) {
            // 转出
            accountDao.outMoney(out, money);
            // 转入
            accountDao.inMoney(in, money);
        }
    });
}
</code></pre>
<p>}</p>
<pre><code>
在上面的代码中，我们使用了 TransactionTemplate 来实现编程式事务，通过 execute 方法来执行事务，这样就可以在方法内部实现事务的控制。

##### 声明式事务管理

本质通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，即在方法执行前开启事务，执行后提交或回滚事务。

缺点：无法像编程式事务那样作用到代码块级别，细粒度只能作用到方法级别。

#### Spring 的事务隔离级别？

1. ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，MySQL 默认可重复读，Oracle 默认读已提交
2. ISOLATION_READ_UNCOMMITTED：读未提交
3. ISOLATION_READ_COMMITTED：读已提交
4. ISOLATION_REPEATABLE_READ：可重复读
5. ISOLATION_SERIALIZABLE：串行化

#### Spring 的事务传播机制

- REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。Spring 的默认传播行为。
- SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。
- MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
- REQUIRES_NEW：总是启动一个新的事务，如果当前存在事务，则将当前事务挂起。
- NOT_SUPPORTED：总是以非事务方式执行，如果当前存在事务，则将当前事务挂起。
- NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前事务不存在，则行为与 REQUIRED 一样。嵌套事务是一个子事务，它依赖于父事务。父事务失败时，会回滚子事务所做的所有操作。但子事务异常不一定会导致父事务的回滚。

**protected 和 private 修饰的方法能加事务吗？**

不能，因为 @Transactional 注解主要是通过 Spring AOP 实现的，而Spring AOP 又是通过 JDK 动态代理和 CGLib 动态代理实现的，它们只能代理公开方法

#### 声明式事务实现原理了解吗？

Spring 的声明式事务管理是通过 AOP（面向切面编程）和代理机制实现的。

第一步，**在 Bean 初始化阶段创建代理对象**：

Spring 容器在初始化单例 Bean 的时候，会遍历所有的 BeanPostProcessor 实现类，并执行其 postProcessAfterInitialization 方法。

在执行 postProcessAfterInitialization 方法时会遍历容器中所有的切面，查找与当前 Bean 匹配的切面，这里会获取事务的属性切面，也就是 `@Transactional` 注解及其属性值。

然后根据得到的切面创建一个代理对象，默认使用 JDK 动态代理创建代理，如果目标类是接口，则使用 JDK 动态代理，否则使用 Cglib。

第二步，**在执行目标方法时进行事务增强操作**：

当通过代理对象调用 Bean 方法的时候，会触发对应的 AOP 增强拦截器，声明式事务是一种环绕增强，对应接口为`MethodInterceptor`，事务增强对该接口的实现为`TransactionInterceptor`，类图如下：

[![图片来源网易技术专栏](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-97493c7f-c596-4e98-a6a8-dab254d6d1ab.png)](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-97493c7f-c596-4e98-a6a8-dab254d6d1ab.png)图片来源网易技术专栏

事务拦截器`TransactionInterceptor`在`invoke`方法中，通过调用父类`TransactionAspectSupport`的`invokeWithinTransaction`方法进行事务处理，包括开启事务、事务提交、异常回滚等。

#### 声明式事务何时会失效？

- @Transactional 应用在非 public 修饰的方法上
- @Transactional 注解属性 propagation、rollbackFor 设置错误
- 同一个类中方法调用，导致 @Transactional 失效

### Spring MVC

#### 对于Spring MVC 的理解

MVC 是模型、视图、控制器的简写，其核心思想是将业务逻辑、数据、显示分离来组织代码

#### Spring MVC 的核心组件有哪些？

1. **DispatcherServlet**：**核心的中央处理器，负责接收请求、分发，并给予客户端响应。**（前置控制器，是整个流程控制的**核心**，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。）
2. **Handler**：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。
3. **HandlerMapping**：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。
4. **HandlerInterceptor**：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。
5. **HandlerExecutionChain**：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要设置额外拦截，可以添加拦截器）。
6. **HandlerAdapter**：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 Java Bean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。
7. **ModelAndView**：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。
8. **ViewResolver**：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。

#### Spring MVC 的工作流程？

① **发起请求**：客户端向服务器发送 HTTP 请求

② **前端控制器**：DispatcherServlet 接收到请求并将请求转发到对应的 Controller

③ **处理器映射**：DispatcherServlet 调用 HandlerMapping 并根据 URL 匹配对应的 Handler（Controller）

④ **处理器适配器**：一旦找到目标 Controller，DispatcherServlet 会使用 HandlerAdapter 来调用 Controller 的方法来处理请求。

⑤ **执行处理器**：Handler 完成用户请求后会返回 ModelAndView 对象，其中包括模型层和视图层

⑥ **视图解析器**：DispatcherServlet 接收到 ModelAndView 后，会使用 ViewResolver 来解析视图名称，找到具体的视图页面。

⑦ **渲染视图**：DispatcherServlet 把返回的 Model 传给 View

⑧ **响应结果**：DispatcherServlet 将视图结果返回给客户端。

**Spring MVC** 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要我们开发人员创建和管理，真正需要处理的只有 **Controller** 、**View** 、**Model**。

&gt; 在前后端分离的情况下，步骤 ⑥、⑦、⑧ 会略有不同，后端通常只需要处理数据，并将 JSON 格式的数据返回给前端就可以了，而不是返回完整的视图页面。

#### SpringMVC Restful 风格的接口的流程是什么样的呢？

1. 客户端向服务器发送 HTTP 请求
2. DispacherServlet 接收请求并将请求转发至对应的 Handler
3. DispacherServlet 调用 HandlerAdapter 根据 URL 找到对应的 Handler
4. Handler（Controller）被封装成了 ServletInvocableHandlerMethod，HandlerAdapter 执行 invokeAndHandler 方法，完成对 Controller 的请求处理
5. HandlerAdapter 执行完成对 Controller 的请求，会调用 HandlerMethodReturnValueHandler 处理返回值
   - 调用 RequestResponseBodyMethodProcessor，创建 ServletServerHttpResoponse （Spring 对原生 ServerHttpResponse 的封装）实例
   - 调用 HttpMessageConverter 的 write 方法，将返回值写入 ServletServerHttpResponse 的输出流中
6. 执行完请求后，返回的 ModelAndView 为 null，ServletServerHttpResponse 里已写入了响应，所以无需关心 View 的处理

### Spring Boot

#### Spring Boot 是什么？有什么优点？

Spring Boot 是一个开源的，用于快速初始化和构建 Spring 应用的脚手架，通过 yml/properties 文件即可配置 Spring、Spring MVC 等许多优秀框架

**优点？**

1. Spring Boot 内嵌 Tomcat、Jetty、Undertow 等容器，不需要在服务器上部署 WAR 包，直接执行 Jar 包就可以启动项目
2. 只需配置 yml/properties 一个配置文件就可以对多种框架进行配置，无需像传统配置 spring.yml、web.xml，Spring Boot 帮我们做了大部分初始工作。（例如只需在项目中引入 spring-boot-starter-web 依赖即可自动引入 tomcat 和 Spring MVC）
   - 通过 yaml 管理约束应用的配置，properties 文件更加便捷和清晰
3. 提供了一系列的 starter 方便集成常用框架，如 Spring Data JPA、Spring Security、MyBatis 、Spring Cloud 等

#### Spring Boot 和 Spring MVC 的区别？

Spring Boot 是一个快速初始化、构建 Spring 的脚手架，能够内嵌 web 容器和集成第三方框架，简化开发步骤提升开发效率

Spring MVC 是 Spring 的一个模块，提供了 MVC 的开发模式，帮助我们构建健壮完善的 web 项目

#### SpringBoot 自动配置原理？

&gt; - 在 Spring 中，自动装配是指容器利用反射机制根据 Bean 的名称、类型（可通过 xml 文件注解来指定装配模式）等自动注入所需的依赖
&gt; - 可以通过 @Autowired、@Resource 等注解来指定成员变量或方法需要被装配
&gt; - @EnableAutoConfiguration 开启自动装配（@SpringBootApplication 包含乐此注解）

1. @EnableAutoConfiguration 的背后是一个非常复杂的自动装配机制，其核心是 AutoConfigurationImportSelector 类
2. AutoConfigurationImportSelector 类实现了 ImportSelector 接口，这个接口的功能主要就是收集需要导入的配置类，配合 @Import 将相应的类导入到 Spring 中
3. 通过 selectImports 方法获取注入类，其实际调用的是 getAutoConfigurationEntry，这个方法是获取自动装配类的关键

[![三分恶面渣逆袭：SpringBoot自动配置原理](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-df77ee15-2ff0-4ec7-8e65-e4ebb8ba88f1.png)](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-df77ee15-2ff0-4ec7-8e65-e4ebb8ba88f1.png)

#### 如何自定义一个 Spring Boot starter？

#### Spring Boot 的启动原理？

1. 判断项目是普通项目还是 web 项目
2. 查找并加载所有可用的初始化器，设置到 initializers 属性中
3. 查找所有的应用程序监听器，设置到 listeners 属性中
4. 找到运行的主类 =&gt; Spring Boot 启动类
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雪荷</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/02/Java%20%E5%85%AB%E8%82%A1%E6%96%87/">http://example.com/2024/07/02/Java%20%E5%85%AB%E8%82%A1%E6%96%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">雪荷的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/post_1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/02/Java%E4%BA%8C%E7%BA%A7/" title="Java二级"><img class="cover" src="/img/post_1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java二级</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/02/OJ%20%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="OJ 项目笔记"><img class="cover" src="/img/post_2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OJ 项目笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/09/22/JVM-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM 面试题"><img class="cover" src="/img/post_1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-22</div><div class="title">JVM 面试题</div></div></a></div><div><a href="/2024/07/07/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/" title="高频面试题"><img class="cover" src="/img/post_1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">高频面试题</div></div></a></div><div><a href="/2024/07/02/2024%E4%B8%8A%E5%8D%8A%E5%B9%B4%E9%9D%A2%E7%BB%8F/" title="2024上半年面经"><img class="cover" src="/img/post_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-02</div><div class="title">2024上半年面经</div></div></a></div><div><a href="/2024/07/02/MySQL%20%E9%9D%A2%E8%AF%95%E9%A2%98/" title="2024上半年面经"><img class="cover" src="/img/post_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-02</div><div class="title">2024上半年面经</div></div></a></div><div><a href="/2024/07/07/RabbitMQ-%E5%85%AB%E8%82%A1%E6%96%87/" title="RabbitMQ 八股文"><img class="cover" src="/img/post_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">RabbitMQ 八股文</div></div></a></div><div><a href="/2024/07/02/Redis%20%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Redis 面试题"><img class="cover" src="/img/post_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-02</div><div class="title">Redis 面试题</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/ava.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">雪荷</div><div class="author-info__description">热爱生活，热爱编程</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%85%AB%E8%82%A1%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text">Java 八股文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">Java 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础概念与常识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Java 语言的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-SE-vs-Java-EE"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Java SE vs Java EE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-vs-JDK-vs-JRE"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">JVM vs JDK vs JRE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">什么是字节码？采用字节码的好处？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Java-%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%92%8C%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%EF%BC%9F"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">为什么说 Java 语言编译和解释并存？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JIT-%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.5.1.</span> <span class="toc-text">JIT 编译模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOT-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8-AOT%EF%BC%9F"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">AOT 有什么优点？为什么不全部使用 AOT？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AOT-%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.1.6.1.</span> <span class="toc-text">AOT 优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8-AOT%EF%BC%9F"><span class="toc-number">1.1.1.6.2.</span> <span class="toc-text">为什么不全部使用 AOT？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%92%8C-C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">Java 和 C++ 的区别?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">Java 注解有几种形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">标识符和关键字的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">Java 语言关键字有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">自增自减运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">移位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%A7%BB%E4%BD%8D%E7%9A%84%E4%BD%8D%E6%95%B0%E8%B6%85%E8%BF%87%E6%95%B0%E5%80%BC%E6%89%80%E5%8D%A0%E6%9C%89%E7%9A%84%E4%BD%8D%E6%95%B0%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">1.1.2.5.1.</span> <span class="toc-text">如果移位的位数超过数值所占有的位数会怎样？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#continue%E3%80%81break-%E5%92%8C-return-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">continue、break 和 return 的区别是什么？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/JVM-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM 面试题"><img src="/img/post_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM 面试题"></a><div class="content"><a class="title" href="/2024/09/22/JVM-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM 面试题">JVM 面试题</a><time datetime="2024-09-22T14:42:32.000Z" title="发表于 2024-09-22 22:42:32">2024-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/21/JUC-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JUC 面试题"><img src="/img/post_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC 面试题"></a><div class="content"><a class="title" href="/2024/09/21/JUC-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JUC 面试题">JUC 面试题</a><time datetime="2024-09-21T14:02:31.000Z" title="发表于 2024-09-21 22:02:31">2024-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/06/%E9%9D%A2%E8%AF%95%E7%8B%97-interviewdog-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="面试狗 - interviewdog 项目笔记"><img src="/img/post_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试狗 - interviewdog 项目笔记"></a><div class="content"><a class="title" href="/2024/09/06/%E9%9D%A2%E8%AF%95%E7%8B%97-interviewdog-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="面试狗 - interviewdog 项目笔记">面试狗 - interviewdog 项目笔记</a><time datetime="2024-09-06T15:49:00.000Z" title="发表于 2024-09-06 23:49:00">2024-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/12/Redisson-%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/" title="Redisson 详细使用"><img src="/img/post_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redisson 详细使用"></a><div class="content"><a class="title" href="/2024/08/12/Redisson-%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/" title="Redisson 详细使用">Redisson 详细使用</a><time datetime="2024-08-12T15:06:31.000Z" title="发表于 2024-08-12 23:06:31">2024-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/29/%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%87%BA-Excel-%E7%9A%84%EF%BC%9F/" title="手摸手教你前端和后端是如何实现导出 Excel 的？"><img src="/img/post_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手摸手教你前端和后端是如何实现导出 Excel 的？"></a><div class="content"><a class="title" href="/2024/07/29/%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%87%BA-Excel-%E7%9A%84%EF%BC%9F/" title="手摸手教你前端和后端是如何实现导出 Excel 的？">手摸手教你前端和后端是如何实现导出 Excel 的？</a><time datetime="2024-07-29T14:59:29.000Z" title="发表于 2024-07-29 22:59:29">2024-07-29</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By 雪荷</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'uTxTLDSTgec4bcmjQMhzZLXJ-gzGzoHsz',
      appKey: 'Mj7im3r78jFLJCaSKJKqGj7m',
      avatar: 'monsterid',
      serverURLs: 'https://utxtldst.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, ))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>