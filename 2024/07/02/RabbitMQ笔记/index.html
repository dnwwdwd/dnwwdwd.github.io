<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RabbitMQ笔记 | 雪荷的博客</title><meta name="author" content="雪荷"><meta name="copyright" content="雪荷"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="消息队列1.1 MQ相关概念1.1.1 什么是MQMQ(message queue),从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ是一种非常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ,不用依赖其他服务。 1.1.2 为什么要用MQ 流量消">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ笔记">
<meta property="og:url" content="http://example.com/2024/07/02/RabbitMQ%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="雪荷的博客">
<meta property="og:description" content="消息队列1.1 MQ相关概念1.1.1 什么是MQMQ(message queue),从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ是一种非常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ,不用依赖其他服务。 1.1.2 为什么要用MQ 流量消">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/post_1.png">
<meta property="article:published_time" content="2024-07-02T07:40:33.000Z">
<meta property="article:modified_time" content="2024-07-03T04:34:26.561Z">
<meta property="article:author" content="雪荷">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/post_1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/02/RabbitMQ%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RabbitMQ笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-03 12:34:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/ava.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/post_1.png')"><nav id="nav"><span id="blog-info"><a href="/" title="雪荷的博客"><span class="site-name">雪荷的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RabbitMQ笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-02T07:40:33.000Z" title="发表于 2024-07-02 15:40:33">2024-07-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-03T04:34:26.561Z" title="更新于 2024-07-03 12:34:26">2024-07-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RabbitMQ笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('/img/post_1.png');"></div><article class="post-content" id="article-container"><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="1-1-MQ相关概念"><a href="#1-1-MQ相关概念" class="headerlink" title="1.1 MQ相关概念"></a>1.1 MQ相关概念</h2><h3 id="1-1-1-什么是MQ"><a href="#1-1-1-什么是MQ" class="headerlink" title="1.1.1 什么是MQ"></a>1.1.1 什么是MQ</h3><p><strong>MQ</strong>(message queue),从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是<br>message而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ是一种非常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ,不用依赖其他服务。</p>
<h3 id="1-1-2-为什么要用MQ"><a href="#1-1-2-为什么要用MQ" class="headerlink" title="1.1.2 为什么要用MQ"></a>1.1.2 为什么要用MQ</h3><ol>
<li><p>流量消峰</p>
<p>比如一个系统1s只能处理一万个下单请求，但在高峰时1s内有2万个下单请求，这时候系统就会崩溃，此时就需要将请求转给MQ，达到消峰的目的。</p>
<p>缺点：请求到达MQ需要排队，导致用户在下单十几秒之后才收到下单成功的操作。<strong>性能差</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105110007685.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105110007685.png" alt="image-20240105110007685"></a></p>
</li>
<li><p>应用解耦</p>
<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中间用户感受不到物流系统的故障，提升系统的可用性。</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105110603912.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105110603912.png" alt="image-20240105110603912"></a></p>
</li>
<li><p>异步处理</p>
<p>B处理完成后向MQ发送消息，MQ又会通知A B的操作已经执行完</p>
<p><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105110913382.png" alt="image-20240105110913382"></p>
</li>
</ol>
<h3 id="1-1-3-MQ的分类"><a href="#1-1-3-MQ的分类" class="headerlink" title="1.1.3 MQ的分类"></a>1.1.3 MQ的分类</h3><ol>
<li><p><strong>Active MQ</strong></p>
<p><strong>优点</strong>：单机吞吐量万级，时效性s级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据<br><strong>缺点</strong>：官方社区现在对ActiveMQ5.x维护越来越少，高吞吐量场景较少使用。<br>尚硅谷官网视频：http:/<a target="_blank" rel="noopener" href="http://www.gulixueyuan.com/course/322">www.gulixueyuan.com/course/322</a></p>
</li>
<li><p><strong>kafka</strong></p>
<p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开Kfka,这款为大数据而生的消息中间件，<br>以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被LinkedIn,Uber,Twitter,Netflix等大公司所采纳。</p>
<p><strong>优点</strong>：性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。时效性s级可用性非常高，kaka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，消费者采用Pu方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方Kafka Web管理界面Kafka-Manager;在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用</p>
<p><strong>缺点</strong>：Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消<br>息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试，支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢。</p>
<p><strong>适合产生大量数据的互联网服务的数据收集业务，有日志采集功能就选它。</strong></p>
</li>
<li><p><strong>Rocket MQ</strong></p>
<p>RocketMQ出自阿里巴巴的开源产品，用]ava语言实现，在设计时参考了Kafka,并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。</p>
<p><strong>优点</strong>：单机吞吐量十万级可用性非常高，分布式架构，消息可以做到0丢失MQ功能较为完善，还是分<br>布式的，扩展性好，支持10亿级别的消息堆积，不会因为堆积导致性能下降，源码是java我们可以自己阅读源码，定制自己公司的MQ<br><strong>缺点</strong>：支持的客户端语言不多，目前是java及c++,其中c++不成熟；社区活跃度一般，没有在MQ核心中去实现JMS等接口，有些系统要迁移需要修改大量代码</p>
<p><strong>天生为金融互联网而生，对于可靠性要求很高的场景。</strong></p>
</li>
<li><p><strong>Rabbit MQ</strong></p>
<p>2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。<br><strong>优点</strong>：由于erlang语言的高并发特性，性能较好；吞吐量到万级，MQ功能比较完备，健壮、稳定、易用、跨平台x支持多种语言如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持A]X文档齐全；开源提供的管理界面非常棒，用起来很好用，社区活跃度高；更新频率相当高<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/news.html">https://www.rabbitmq.com/news.html</a><br><strong>缺点</strong>：商业版需要收费，学习成本较高</p>
</li>
</ol>
<p> <strong>适合数据量不是特别大的场景。</strong></p>
<h2 id="1-2-Rabbit-MQ"><a href="#1-2-Rabbit-MQ" class="headerlink" title="1.2 Rabbit MQ"></a>1.2 Rabbit MQ</h2><h3 id="1-2-1-Rabbit-MQ的概念"><a href="#1-2-1-Rabbit-MQ的概念" class="headerlink" title="1.2.1 Rabbit MQ的概念"></a>1.2.1 Rabbit MQ的概念</h3><p>RabbitMQ是一个消息中间件：它接收并转发消息，但不处理。</p>
<h3 id="1-2-2-四大核心概念"><a href="#1-2-2-四大核心概念" class="headerlink" title="1.2.2 四大核心概念"></a>1.2.2 四大核心概念</h3><ul>
<li>生产者</li>
<li>交换机</li>
<li>队列</li>
<li>消费者</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105121106424.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105121106424.png" alt="image-20240105121106424"></a></p>
<h3 id="1-2-3-Rabbit-MQ核心部分"><a href="#1-2-3-Rabbit-MQ核心部分" class="headerlink" title="1.2.3 Rabbit MQ核心部分"></a>1.2.3 Rabbit MQ核心部分</h3><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105121230697.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105121230697.png" alt="image-20240105121230697"></a></p>
<h3 id="1-2-4-各个名词介绍"><a href="#1-2-4-各个名词介绍" class="headerlink" title="1.2.4 各个名词介绍"></a>1.2.4 各个名词介绍</h3><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105121329176.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105121329176.png" alt="image-20240105121329176"></a></p>
<p><strong>Broker</strong>：接收和分发消息的应用，Rabbit MQ Server就是Message Broker</p>
<p><strong>Connection</strong>：消费者/生产者和broker之间的<strong>TCP</strong>连接</p>
<p><strong>Channel</strong>:如果每一次访问RabbitMQ都建立一个Connection,在消息量大的时候建立TCP<br>Connection的开销将是巨大的，效率也较低。Channel是在connection内部建立的逻辑连接，如果应用程序支特多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel,,所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</p>
<p><strong>Virtual host</strong>：出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost,每个用户在自己的vhost创建exchange/queue等</p>
<p><strong>Exchange</strong>：message到达broker的第一站，根据分发规则，匹配查询表中的routing key,分发消息到queue中去。常用的类型有：direct(point-.to-point),topic(publish-subscribe)and fanout(multicast)<br><strong>Queue</strong>：消息最终被送到这里等待consumer取走<br><strong>Binding</strong>：exchange和queue之间的虚拟连接，binding中可以包含routing key,Binding信息被保存到exchange中的查询表中，用于message的分发依据</p>
<h2 id="2-hello-world——RabbitMQ初使用"><a href="#2-hello-world——RabbitMQ初使用" class="headerlink" title="2. hello world——RabbitMQ初使用"></a>2. hello world——RabbitMQ初使用</h2><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-创建生产者和消费者"><a href="#2-2-创建生产者和消费者" class="headerlink" title="2.2 创建生产者和消费者"></a>2.2 创建生产者和消费者</h3><p>生产者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Producer1 {</span><br><span class="line">    // 队列名称</span><br><span class="line">    public static final String QUEUE_NAME = "hello";</span><br><span class="line"></span><br><span class="line">    // 发消息</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException {</span><br><span class="line">        // 创建工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        // 设置工厂 IP 连接RabbitMQ的队列</span><br><span class="line">        factory.setHost("localhost");</span><br><span class="line">        // 用户名和密码</span><br><span class="line">        factory.setUsername("guest");</span><br><span class="line">        factory.setPassword("guest");</span><br><span class="line">        // 获取信道</span><br><span class="line">        // 创建连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        // 获取信道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /**</span><br><span class="line">         * 生成一个队列</span><br><span class="line">         * 1.队列名称</span><br><span class="line">         * 2.队列中消息是否持久化（存在磁盘中） 默认情况下消息存在内容中</span><br><span class="line">         * 3.该队列是否只供一个消费者消费 （是否进行消息共享）true：可以多个消费者消费  false：只能一个消费者消费</span><br><span class="line">         * 4.是否自动删除 最后一个消费者端开连接以后该队一句是否自动删除true自动删除false不自动删除</span><br><span class="line">         * 5.其它参数</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">        // 发消息</span><br><span class="line">        String message = "hello world";</span><br><span class="line">        /**</span><br><span class="line">         * 发送一个消费</span><br><span class="line">         * 1.发送到哪个交换机</span><br><span class="line">         * 2.路由的Key值是哪个 本次是队列的名称</span><br><span class="line">         * 3.其它参数信息</span><br><span class="line">         * 4.发送消息的本体</span><br><span class="line">         */</span><br><span class="line">        channel.basicPublish("", QUEUE_NAME, null, message.getBytes());</span><br><span class="line">        System.out.println("消息发送完毕");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>消费者</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Consumer1 {</span><br><span class="line">    // 队列的名称</span><br><span class="line">    public static final String QUEUE_NAME = "hello";</span><br><span class="line">    // 接收消息</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException {</span><br><span class="line">        // 创建连接工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost("localhost");</span><br><span class="line">        factory.setUsername("guest");</span><br><span class="line">        factory.setPassword("guest");</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        // 创建信道 </span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明 接收到了消息</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println(new String(message.getBody()));</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        // 声明 取消接收消息时的回调</span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("消息消费被中断");</span><br><span class="line">        };</span><br><span class="line">        /**</span><br><span class="line">         * 消费者消费信息</span><br><span class="line">         * 1.消费哪个队列</span><br><span class="line">         * 2.消费成功后是否要应答</span><br><span class="line">         * 3.消费者未成功消费的回调</span><br><span class="line">         * 4.消费者取消消费的回调</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">         channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-Work-Queues（工作队列）"><a href="#3-Work-Queues（工作队列）" class="headerlink" title="3. Work Queues（工作队列）"></a>3. Work Queues（工作队列）</h2><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105144005543.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105144005543.png" alt="img"></a></p>
<h3 id="3-1-轮询分发消息"><a href="#3-1-轮询分发消息" class="headerlink" title="3.1 轮询分发消息"></a>3.1 轮询分发消息</h3><p>可以创建两个工作线程/消费者接收消息，创建一个什么生产者不断发送消息，这时候会发现有一个线程成功接收第一次发送消息，则不会接收第二次发送的消息，而第二次发送的消息则是被另一个线程接收了。<strong>即两个工作线程不能同时接收同一个消息，消息的接收是一个轮询机制。</strong></p>
<h3 id="3-2-消息应答"><a href="#3-2-消息应答" class="headerlink" title="3.2 消息应答"></a>3.2 消息应答</h3><h4 id="3-2-1概念"><a href="#3-2-1概念" class="headerlink" title="3.2.1概念"></a>3.2.1概念</h4><p>为了保证消息在发送过程中不丢失，RabbitMQ引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉RabbitMQ它己经处理了，RabbitMQ可以把该消息删除了。</p>
<h4 id="3-2-2-自动应答"><a href="#3-2-2-自动应答" class="headerlink" title="3.2.2 自动应答"></a>3.2.2 自动应答</h4><p>这种模式需要在高吞吐量和数据传输安全性方面做权衡。仅适用于在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p>
<p>一旦消息被接收了就会应答，如果消息处理失败了，还是会应答，这样会导致消息的丢失。</p>
<h4 id="3-2-3-消息应答的方式"><a href="#3-2-3-消息应答的方式" class="headerlink" title="3.2.3 消息应答的方式"></a>3.2.3 消息应答的方式</h4><ul>
<li>Channel.basicAck(用于肯定确认) RabbitMQ已知道该消息并且成功的处理消息，可以将其丢弃了 <strong>开启自动应答</strong></li>
<li>Channel.basicNack(用于否定确认) <strong>关闭自动应答</strong></li>
<li>Channel.basicReject(用于否定确认)，与Channel.basicNack相比少一个参数。不处理该消息了直接拒绝，可以将其丢弃了</li>
</ul>
<h4 id="3-2-4-Multiple的解释"><a href="#3-2-4-Multiple的解释" class="headerlink" title="3.2.4 Multiple的解释"></a>3.2.4 Multiple的解释</h4><p>手动应答好处是可以批量应答且减少网络拥堵</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105150909044.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105150909044.png" alt="image-20240105150909044"></a></p>
<h4 id="3-2-5-消息自动重新入队"><a href="#3-2-5-消息自动重新入队" class="headerlink" title="3.2.5 消息自动重新入队"></a>3.2.5 消息自动重新入队</h4><p>如果消费者因为某些原因失去了连接，导致消息未发送ACK确认，MQ则知道消息未完全处理，并将此消息重新入队。如果其他其他消费者可以处理，它将会很快安排其他消费者进行处理。</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105152233304.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240105152233304.png" alt="img"></a></p>
<h4 id="3-2-6-MQ开启手动应答"><a href="#3-2-6-MQ开启手动应答" class="headerlink" title="3.2.6 MQ开启手动应答"></a>3.2.6 MQ开启手动应答</h4><p>MQ开启手动应答消息是不会丢失的，如果有一个工作线程挂掉了，本该被C2处理的消息会被转发到C1线程进行处理</p>
<h4 id="3-6-7-手动应答实战"><a href="#3-6-7-手动应答实战" class="headerlink" title="3.6.7 手动应答实战"></a>3.6.7 手动应答实战</h4><p>生产者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * 消息在手动应答时是不丢，放回队列中重新消费</span><br><span class="line"> */</span><br><span class="line">public class Task2 {</span><br><span class="line">    public static final String task_queue_name = "ack_queue";</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = (Channel) RabbitMQUtils.getChannel();</span><br><span class="line">        // 声明队列</span><br><span class="line">        boolean durable = true;</span><br><span class="line">        channel.queueDeclare(task_queue_name, durable, false, false, null);</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext()) {</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            // 设置生产者发送消息为持久化消息（要求保存在磁盘中） 不设置则保存在内存中</span><br><span class="line">            channel.basicPublish("", task_queue_name, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes("UTF-8"));</span><br><span class="line">            System.out.println("生产者发送消息：" + message);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>消费者1：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * 消息在手动应答时是不丢失的，放回队列中重新消费</span><br><span class="line"> */</span><br><span class="line">public class Work03 {</span><br><span class="line">    // 队列名称</span><br><span class="line">    public static final String task_queue_name = "ack_queue";</span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println("C1等待接收消息处理时间较短");</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag,message) -&gt; {</span><br><span class="line">            SleepUtils.sleep(1);</span><br><span class="line">            System.out.println("接收到的消息" + new String(message.getBody()));</span><br><span class="line">            // 手动应答</span><br><span class="line">            /**</span><br><span class="line">             * 1.消息的标记 tag</span><br><span class="line">             * 2.是否批量应答 false不批量应答信道中的消息 反之批量</span><br><span class="line">             */</span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">        };</span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line"></span><br><span class="line">        };</span><br><span class="line">        // 设置不公平分发</span><br><span class="line">        int prefetchCount = 2;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line">        // 采用手动应答</span><br><span class="line">        boolean autoAck = false;</span><br><span class="line">        channel.basicConsume(task_queue_name, autoAck, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>消费者2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Work04 {</span><br><span class="line">        // 队列名称</span><br><span class="line">        public static final String task_queue_name = "ack_queue";</span><br><span class="line">        public static void main(String[] args) throws IOException {</span><br><span class="line">            Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">            System.out.println("C2等待接收消息处理时间较长");</span><br><span class="line">            DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">                SleepUtils.sleep(30);</span><br><span class="line">                System.out.println("接收到的消息" + new String(message.getBody()));</span><br><span class="line">                // 手动应答</span><br><span class="line">                /**</span><br><span class="line">                 * 1.消息的标记 tag</span><br><span class="line">                 * 2.是否批量应答 false不批量应答信道中的消息 反之批量</span><br><span class="line">                 */</span><br><span class="line">                channel.basicAck(message.getEnvelope().getDeliveryTag(), false);</span><br><span class="line">            };</span><br><span class="line">            CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">                System.out.println("已取消");</span><br><span class="line">            };</span><br><span class="line">            int prefetchCount = 5;</span><br><span class="line">            channel.basicQos(prefetchCount);</span><br><span class="line">            channel.basicConsume(task_queue_name, false, deliverCallback, cancelCallback);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-RabbitMQ持久化"><a href="#3-3-RabbitMQ持久化" class="headerlink" title="3.3 RabbitMQ持久化"></a>3.3 RabbitMQ持久化</h3><h4 id="3-3-1-概念"><a href="#3-3-1-概念" class="headerlink" title="3.3.1 概念"></a>3.3.1 概念</h4><p>之前我们创建的队列都是非持久化的，rabbitmq如果重启的话，该队列就会被删除掉，如果<br>要队列实现持久化需要在声明队列的时候把durable参数设置为持久化。</p>
<h4 id="3-3-2-队列如何实现持久化"><a href="#3-3-2-队列如何实现持久化" class="headerlink" title="3.3.2 队列如何实现持久化"></a>3.3.2 队列如何实现持久化</h4><p>在声明队列时，将durable改为true</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">boolean durable = true;</span><br><span class="line">channel.queueDeclare(*queue_name*, durable, false, false, null);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-3-消息实现持久化"><a href="#3-3-3-消息实现持久化" class="headerlink" title="3.3.3 消息实现持久化"></a>3.3.3 消息实现持久化</h4><p>将消息标记为持久化时并不能完全保证不会丢失消息，因为其在刚准备存入磁盘时，但还没有存储完磁盘中，消息还在缓存的一个间隔点，此时并没有真正存入磁盘，持久性保证并不强。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">channel.basicPublish("", task_queue_name, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes("UTF-8"));</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-4-不公平分发（能者多劳）"><a href="#3-3-4-不公平分发（能者多劳）" class="headerlink" title="3.3.4 不公平分发（能者多劳）"></a>3.3.4 不公平分发（能者多劳）</h4><p>RabbitMQ分发消息采用轮训分发，如果有的消费者消费慢，但有的消费快，其会导致快的消费者很闲，所以应该采用<strong>不公平</strong>分发。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">channel.basicQos(1); //设置在消费方</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-3-5预取值"><a href="#3-3-5预取值" class="headerlink" title="3.3.5预取值"></a>3.3.5预取值</h4><p>预先设置消费者消费的消息数，通过channel信道设置。prefetchCount指的是信道的积压的信息数。</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240106205108937.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240106205108937.png" alt="image-20240106205108937"></a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">int prefetchCount = 2; // 要求 &gt; 1</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-发布确认"><a href="#4-发布确认" class="headerlink" title="4. 发布确认"></a>4. 发布确认</h2><h3 id="4-1-发布确认原理"><a href="#4-1-发布确认原理" class="headerlink" title="4.1 发布确认原理"></a>4.1 发布确认原理</h3><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240106210500084.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240106210500084.png" alt="image-20240106210500084"></a></p>
<ol>
<li>要求队列必须持久化</li>
<li>消息也必须持久化</li>
<li>成功保存在磁盘上后才会进行发布确认（存在磁盘后就会告诉生产者）</li>
</ol>
<h3 id="4-2-发布确认的策略"><a href="#4-2-发布确认的策略" class="headerlink" title="4.2 发布确认的策略"></a>4.2 发布确认的策略</h3><h4 id="4-2-1-单个确认发布"><a href="#4-2-1-单个确认发布" class="headerlink" title="4.2.1 单个确认发布"></a>4.2.1 单个确认发布</h4><p>发布一个消息确认一个，性能差，但消息丢失能知道哪个消息丢失了</p>
<p>发布一千个消息用时368ms</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public static void publishMessageIndividually() throws Exception{</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        // 队列的声明</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">        // 开启确认发布</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        // 开启时间</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line">        // 大量发消息</span><br><span class="line">        for (int i = 0;i &lt; MESSAGE_COUNT; i++) {</span><br><span class="line">            String message = i + "";</span><br><span class="line">            channel.basicPublish("", queueName, null, message.getBytes());</span><br><span class="line">            boolean flag = channel.waitForConfirms();</span><br><span class="line">            if (flag) {</span><br><span class="line">                System.out.println("消息发送成功");</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        // 结束时间</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println("发布1000个消息单个确认耗时" + (end-begin) +"ms");</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-2-2-批量确认发布"><a href="#4-2-2-批量确认发布" class="headerlink" title="4.2.2 批量确认发布"></a>4.2.2 批量确认发布</h4><p>发布完一堆消息后再进行统一确认，如果有消息出问题难以定位出错的是哪一个</p>
<p>发布一千个消息用时48ms</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public static void publishMessageBatch() throws IOException, InterruptedException {</span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    // 队列的声明</span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">    // 开启确认发布</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    // 开启时间</span><br><span class="line">    long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    //批量确认消息的大小</span><br><span class="line">    int batchSize = 1000;</span><br><span class="line">    for (int i = 0; i&lt; MESSAGE_COUNT; i++) {</span><br><span class="line">        String message = i+"";</span><br><span class="line">        channel.basicPublish("", queueName, null, message.getBytes());</span><br><span class="line"></span><br><span class="line">        if (i%batchSize == 0) {</span><br><span class="line">            // 发布确认</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    // 结束时间</span><br><span class="line">    long end = System.currentTimeMillis();</span><br><span class="line">    System.out.println("发布1000个消息批量确认耗时" + (end-begin) +"ms");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-2-3-异步确认发布"><a href="#4-2-3-异步确认发布" class="headerlink" title="4.2.3 异步确认发布"></a>4.2.3 异步确认发布</h4><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说，<br>他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功。</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240106213814548.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240106213814548.png" alt="image-20240106213814548"></a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">// 异步确认发布</span><br><span class="line">    public static void publishMessageAsync() throws Exception{</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        // 队列的声明</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">        // 开启确认发布</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        // 开启时间</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        // 消息确认成功的回调方法</span><br><span class="line">        ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt; {</span><br><span class="line">            System.out.println("确认的消息：" + deliveryTag);</span><br><span class="line">        };</span><br><span class="line">        // 消息确认失败的回调方法</span><br><span class="line">        /**</span><br><span class="line">         * 1.消息的标识 deliveryTag</span><br><span class="line">         * 2.是否批量 multiple</span><br><span class="line">         */</span><br><span class="line">        ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; {</span><br><span class="line">            System.out.println("未确认的消息：" + deliveryTag);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        // 准备消息的监听器 监听哪些消息成功了 哪些些消息失败了</span><br><span class="line">        /**</span><br><span class="line">         * 1.监听哪些消息成功了</span><br><span class="line">         * 2.监听那些消息失败了</span><br><span class="line">         */</span><br><span class="line">        channel.addConfirmListener(ackCallback, nackCallback);  // 监听器有两种，一种只监听成功的，一种成功的和失败的都监听，这里的话是后者</span><br><span class="line"></span><br><span class="line">        // 批量确认发布</span><br><span class="line">        for (int i = 0; i &lt; MESSAGE_COUNT; i++) {</span><br><span class="line">            String message = i+"";</span><br><span class="line">            channel.basicPublish("", queueName, null, message.getBytes());</span><br><span class="line">            // 发布确认 异步</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 结束时间</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println("发布1000个消息异步确认发布耗时" + (end-begin) +"ms");</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><strong>如何处理异步未确认的消息</strong></p>
<p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用ConcurrentLinkedQueue这个队列在confirm callbacks与发布线程之间进行消息的传<br>递。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">// 异步确认发布</span><br><span class="line">public static void publishMessageAsync() throws Exception{</span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    // 队列的声明</span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">    // 开启确认发布</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    // 开启时间</span><br><span class="line">    long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 线程安全有序的一个哈希表 适用于高并发的情况下</span><br><span class="line">     * 1.轻松的将序号与消息进行关联</span><br><span class="line">     * 2.轻松批量删除条目，只要给到序号</span><br><span class="line">     * 3.支持高并发（多线程）</span><br><span class="line">     */</span><br><span class="line">    ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = new ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 消息确认成功的回调方法</span><br><span class="line">    ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt; {</span><br><span class="line">        // 如果是批量发布消息，则批量删除</span><br><span class="line">        if (multiple) {</span><br><span class="line">            // 2.删除掉已经确认的消息，剩下就是未确认的消息</span><br><span class="line">            ConcurrentNavigableMap&lt;Long, String&gt; confirmedMap =</span><br><span class="line">                    outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">            confirmedMap.clear();</span><br><span class="line">        } else {</span><br><span class="line">            // 单个确认</span><br><span class="line">            outstandingConfirms.remove(deliveryTag);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println("确认的消息是：" + deliveryTag);</span><br><span class="line">    };</span><br><span class="line">    // 消息确认失败的回调方法</span><br><span class="line">    /**</span><br><span class="line">     * 1.消息的标识 deliveryTag</span><br><span class="line">     * 2.是否批量 multiple</span><br><span class="line">     */</span><br><span class="line">    ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; {</span><br><span class="line">        String message = outstandingConfirms.get(deliveryTag);</span><br><span class="line">        // 3.打印未确认的消息有哪些</span><br><span class="line">        System.out.println("未确认的消息是：" + message + "未确认消息的标记是：" + deliveryTag);</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    // 准备消息的监听器 监听哪些消息成功了 哪些些消息失败了</span><br><span class="line">    /**</span><br><span class="line">     * 1.监听哪些消息成功了</span><br><span class="line">     * 2.监听那些消息失败了</span><br><span class="line">     */</span><br><span class="line">    channel.addConfirmListener(ackCallback, nackCallback);  // 监听器有两种，一种只监听成功的，一种成功的和失败的都监听，这里的话是后者</span><br><span class="line"></span><br><span class="line">    // 批量确认发布</span><br><span class="line">    for (int i = 0; i &lt; MESSAGE_COUNT; i++) {</span><br><span class="line">        String message = i+"";</span><br><span class="line">        channel.basicPublish("", queueName, null, message.getBytes());</span><br><span class="line">        // 1. 此处记录下所有要发送消息，消息的总和</span><br><span class="line">        outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">        // 发布确认 异步</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    // 结束时间</span><br><span class="line">    long end = System.currentTimeMillis();</span><br><span class="line">    System.out.println("发布1000个消息异步确认发布耗时" + (end-begin) +"ms");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-2-4-三种发布的对比"><a href="#4-2-4-三种发布的对比" class="headerlink" title="4.2.4 三种发布的对比"></a>4.2.4 三种发布的对比</h4><p><strong>单独发布消息</strong><br>同步等待确认，简单，但吞吐量非常有限。<br><strong>批量发布消息</strong><br>批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条<br>消息出现了问题。<br><strong>异步处理：</strong><br>最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p>
<h4 id="4-2-5-发布确认实战"><a href="#4-2-5-发布确认实战" class="headerlink" title="4.2.5 发布确认实战"></a>4.2.5 发布确认实战</h4><p>ConfirmMessage：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * 发布确认模式</span><br><span class="line"> * 1.单个确认</span><br><span class="line"> * 2.批量确认</span><br><span class="line"> * 3.异步批量确认</span><br><span class="line"> */</span><br><span class="line">public class ConfirmMessage {</span><br><span class="line">    public static final int MESSAGE_COUNT = 1000;</span><br><span class="line">    public static void main(String[] args) throws Exception {</span><br><span class="line">        // 发布确认模式</span><br><span class="line">        // 1.单个确认</span><br><span class="line">        // 2.批量确认</span><br><span class="line">        // 3.异步批量确认</span><br><span class="line">        publishMessageAsync();</span><br><span class="line">    }</span><br><span class="line">    // 单个确认发布</span><br><span class="line">    public static void publishMessageIndividually() throws Exception{</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        // 队列的声明</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">        // 开启确认发布</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        // 开启时间</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line">        // 大量发消息</span><br><span class="line">        for (int i = 0;i &lt; MESSAGE_COUNT; i++) {</span><br><span class="line">            String message = i + "";</span><br><span class="line">            channel.basicPublish("", queueName, null, message.getBytes());</span><br><span class="line">            boolean flag = channel.waitForConfirms();</span><br><span class="line">            if (flag) {</span><br><span class="line">                System.out.println("消息发送成功");</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        // 结束时间</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println("发布1000个消息单个确认耗时" + (end-begin) +"ms");</span><br><span class="line">    }</span><br><span class="line">    // 批量确认发布</span><br><span class="line">    public static void publishMessageBatch() throws IOException, InterruptedException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        // 队列的声明</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">        // 开启确认发布</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        // 开启时间</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        //批量确认消息的大小</span><br><span class="line">        int batchSize = 1000;</span><br><span class="line">        for (int i = 0; i&lt; MESSAGE_COUNT; i++) {</span><br><span class="line">            String message = i+"";</span><br><span class="line">            channel.basicPublish("", queueName, null, message.getBytes());</span><br><span class="line"></span><br><span class="line">            if (i%batchSize == 0) {</span><br><span class="line">                // 发布确认</span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        // 结束时间</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println("发布1000个消息批量确认耗时" + (end-begin) +"ms");</span><br><span class="line">    }</span><br><span class="line">    // 异步确认发布</span><br><span class="line">    public static void publishMessageAsync() throws Exception{</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        // 队列的声明</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, true, false, false, null);</span><br><span class="line">        // 开启确认发布</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        // 开启时间</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 线程安全有序的一个哈希表 适用于高并发的情况下</span><br><span class="line">         * 1.轻松的将序号与消息进行关联</span><br><span class="line">         * 2.轻松批量删除条目，只要给到序号</span><br><span class="line">         * 3.支持高并发（多线程）</span><br><span class="line">         */</span><br><span class="line">        ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = new ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 消息确认成功的回调方法</span><br><span class="line">        ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt; {</span><br><span class="line">            // 如果是批量发布消息，则批量删除</span><br><span class="line">            if (multiple) {</span><br><span class="line">                // 2.删除掉已经确认的消息，剩下就是未确认的消息</span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirmedMap =</span><br><span class="line">                        outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">                confirmedMap.clear();</span><br><span class="line">            } else {</span><br><span class="line">                // 单个确认</span><br><span class="line">                outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println("确认的消息是：" + deliveryTag);</span><br><span class="line">        };</span><br><span class="line">        // 消息确认失败的回调方法</span><br><span class="line">        /**</span><br><span class="line">         * 1.消息的标识 deliveryTag</span><br><span class="line">         * 2.是否批量 multiple</span><br><span class="line">         */</span><br><span class="line">        ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; {</span><br><span class="line">            String message = outstandingConfirms.get(deliveryTag);</span><br><span class="line">            // 3.打印未确认的消息有哪些</span><br><span class="line">            System.out.println("未确认的消息是：" + message + "未确认消息的标记是：" + deliveryTag);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        // 准备消息的监听器 监听哪些消息成功了 哪些些消息失败了</span><br><span class="line">        /**</span><br><span class="line">         * 1.监听哪些消息成功了</span><br><span class="line">         * 2.监听那些消息失败了</span><br><span class="line">         */</span><br><span class="line">        channel.addConfirmListener(ackCallback, nackCallback);  // 监听器有两种，一种只监听成功的，一种成功的和失败的都监听，这里的话是后者</span><br><span class="line"></span><br><span class="line">        // 批量确认发布</span><br><span class="line">        for (int i = 0; i &lt; MESSAGE_COUNT; i++) {</span><br><span class="line">            String message = i+"";</span><br><span class="line">            channel.basicPublish("", queueName, null, message.getBytes());</span><br><span class="line">            // 1. 此处记录下所有要发送消息，消息的总和</span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">            // 发布确认 异步</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        // 结束时间</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println("发布1000个消息异步确认发布耗时" + (end-begin) +"ms");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-交换机"><a href="#5-交换机" class="headerlink" title="5. 交换机"></a>5. 交换机</h2><p>老模式：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107145458380.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107145458380.png" alt="image-20240107145458380"></a></p>
<p>新模式：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107145348452.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107145348452.png" alt="image-20240107145348452"></a></p>
<h3 id="5-1-Exchange"><a href="#5-1-Exchange" class="headerlink" title="5.1 Exchange"></a>5.1 Exchange</h3><h4 id="5-1-1-Exchange的概念"><a href="#5-1-1-Exchange的概念" class="headerlink" title="5.1.1 Exchange的概念"></a>5.1.1 Exchange的概念</h4><p><strong>RabbitMQ消息传递模型的核心思想</strong>：生产者生产的消息从不会直接发送到队列，甚至生产者也不知道消息传递到了哪个队列中。</p>
<p>生产者将消息发送给交换机，交换机会把接收的消息推入队列，交换机负责把这些消息放入指定的队列或者将其丢弃。其由交换机的类型决定。</p>
<h4 id="5-1-2-无名Exchange"><a href="#5-1-2-无名Exchange" class="headerlink" title="5.1.2 无名Exchange"></a>5.1.2 无名Exchange</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">channel.basicPublish("", QUEUE_NAME, null, message.getBytes());</span><br></pre></td></tr></tbody></table></figure>

<p>第一个参数是交换机的名称，空字符串表示默认或无名交换机；消息能路由发送到队列其实是由routingKey（bindingkey）绑定key指定的。</p>
<h3 id="5-2-临时队列"><a href="#5-2-临时队列" class="headerlink" title="5.2 临时队列"></a>5.2 临时队列</h3><p>临时队列无名称。</p>
<p>创建临时队列的方式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">String queueName = channel.queueDeclare.getQueue();</span><br></pre></td></tr></tbody></table></figure>

<p>创建后的样子：<a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107151214602.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107151214602.png" alt="image-20240107151214602"></a></p>
<h3 id="5-3-绑定队列"><a href="#5-3-绑定队列" class="headerlink" title="5.3 绑定队列"></a>5.3 绑定队列</h3><p>可以指定交换机绑定某个队列，通过绑定routingKey将消息传递给指定的队列</p>
<h4 id="5-3-1-Fanout（扇出模式）"><a href="#5-3-1-Fanout（扇出模式）" class="headerlink" title="5.3.1 Fanout（扇出模式）"></a>5.3.1 Fanout（扇出模式）</h4><p>一个生产者发消息，多个消费者接收的都是一样的消息（<strong>随意广播</strong>），适用于发布订阅模式、打日志和多个系统共享等，消息会被转发到所有绑定到该交换机的队列上。</p>
<h4 id="5-3-2-Fanout交换机实战"><a href="#5-3-2-Fanout交换机实战" class="headerlink" title="5.3.2 Fanout交换机实战"></a>5.3.2 Fanout交换机实战</h4><p>消费者1：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Receiver1 {</span><br><span class="line">    public static final String EXCHANGE_NAME = "logs";</span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        // 声明一个交换机</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");</span><br><span class="line">        // 声明一个临时队列，名称是随机的</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, "");</span><br><span class="line">        System.out.println("R1等待接收消息，把接收到消息打印在控制台上");</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println("R1接收到的消息：" + new String(message.getBody()));</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("R1取消消息");</span><br><span class="line">        };</span><br><span class="line">        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>消费者2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Receiver2 {</span><br><span class="line">    public static final String EXCHANGE_NAME = "logs";</span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        // 声明一个交换机</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");</span><br><span class="line">        // 声明一个临时队列，名称是随机的</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, "");</span><br><span class="line">        System.out.println("R2等待接收消息，把接收到消息打印在控制台上");</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println("R2接收到的消息：" + new String(message.getBody()));</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("R2取消消息");</span><br><span class="line">        };</span><br><span class="line">        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>生产者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Emit {</span><br><span class="line">    public static final String EXCHANGE_NAME = "logs";</span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext()) {</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes("UTF-8"));</span><br><span class="line">            System.out.println("生产者发出消息：" + message);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-3-3-Direct-exchange"><a href="#5-3-3-Direct-exchange" class="headerlink" title="5.3.3 Direct exchange"></a>5.3.3 Direct exchange</h4><p>一个生产者发消息可以指定消费者接收某个消息或者不接收某个消息，当然也可以指定所有消费者都接收一样的消息（<strong>有选择性接收日志</strong>）</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107162131445.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107162131445.png" alt="image-20240107162131445"></a></p>
<p>直接绑定但绑定的多个队列key相同</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107162400370.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107162400370.png" alt="image-20240107162400370"></a></p>
<h4 id="5-3-4-Direct交换机实战"><a href="#5-3-4-Direct交换机实战" class="headerlink" title="5.3.4 Direct交换机实战"></a>5.3.4 Direct交换机实战</h4><p>消费者1：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Receiver1 {</span><br><span class="line">    public static final String EXCHANGE_NAME = "direct";</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, "direct");</span><br><span class="line">        channel.queueDeclare("console", false, false, false, null);</span><br><span class="line">        channel.queueBind("console", EXCHANGE_NAME, "info");</span><br><span class="line">        channel.queueBind("console", EXCHANGE_NAME, "warning");</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println("R1接收到的消息：" + new String(message.getBody()));</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("R1取消消息");</span><br><span class="line">        };</span><br><span class="line">        channel.basicConsume("console", true, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>消费者2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Receiver2 {</span><br><span class="line">    public static final String EXCHANGE_NAME = "direct";</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, "direct");</span><br><span class="line">        channel.queueDeclare("disk", false, false, false, null);</span><br><span class="line">        channel.queueBind("disk", EXCHANGE_NAME, "error");</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println("R2接收到的消息：" + new String(message.getBody()));</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("R2取消消息");</span><br><span class="line">        };</span><br><span class="line">        channel.basicConsume("console", true, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>生产者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public class Emit {</span><br><span class="line">    public static final String EXCHANGE_NAME = "direct";</span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, "direct");</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext()) {</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, "info", null, message.getBytes());</span><br><span class="line">            System.out.println("生产者发送消息：" + message);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-3-5-多重绑定"><a href="#5-3-5-多重绑定" class="headerlink" title="5.3.5 多重绑定"></a>5.3.5 多重绑定</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, "info", null, message.getBytes());</span><br></pre></td></tr></tbody></table></figure>

<p>routingKey决定把消息发送给哪个消费者，上面是把消息发送给绑定了info的队列</p>
<h3 id="5-4-Topic交换机"><a href="#5-4-Topic交换机" class="headerlink" title="5.4 Topic交换机"></a>5.4 Topic交换机</h3><h4 id="5-4-1-前几种交换机模式的缺陷："><a href="#5-4-1-前几种交换机模式的缺陷：" class="headerlink" title="5.4.1 前几种交换机模式的缺陷："></a>5.4.1 前几种交换机模式的缺陷：</h4><p>尽管使用direct交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base和info.advantage,某个队列只想要info.base的消息，那这个时候direct就办不到了。这个时候就只能使用topic类型</p>
<h4 id="5-4-2-Topic交换机对routingKey的书写要求"><a href="#5-4-2-Topic交换机对routingKey的书写要求" class="headerlink" title="5.4.2 Topic交换机对routingKey的书写要求"></a>5.4.2 Topic交换机对routingKey的书写要求</h4><p>发送到类型是topic交换机的消息的routingkey不能随意写，必须满足一定的要求，它必须是一个单<br>词列表，以点号分隔开。这些单词可以是任意单词，比如说：”stock.usd.nyse”,”nye.mw”,<br>‘quick.orange.rabbit’”.这种类型的。当然这个单词列表最多不能超过255个字节。<br>在这个规则列表中，其中有两个替换符是大家需要注意的<br>*(星号)可以代替一个单词<br>#(井号)可以替代零个或多个单词</p>
<h4 id="5-4-3-Topic匹配案例"><a href="#5-4-3-Topic匹配案例" class="headerlink" title="5.4.3 Topic匹配案例"></a>5.4.3 Topic匹配案例</h4><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107173915321.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107173915321.png" alt="image-20240107173915321"></a></p>
<p>如果有一个消息符合同一个队列的两个绑定条件，但是它只会被该队列接收一次。如果有消息不符合任意一个绑定条件，则会被丢弃。</p>
<h4 id="5-4-4-Topic交换机实战："><a href="#5-4-4-Topic交换机实战：" class="headerlink" title="5.4.4 Topic交换机实战："></a>5.4.4 Topic交换机实战：</h4><p>消费者1：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class ReceiverTopic1 {</span><br><span class="line">    public static final String EXCHANGE_NAME = "topic";</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, "topic");</span><br><span class="line">        String queueName = "Q1";</span><br><span class="line">        channel.queueDeclare(queueName, false, false, false, null); // 不持久化，不共享，不自动删除，无参数</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, "*.orange.*");</span><br><span class="line">        System.out.println("Q1等待接收消息");</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println("Q1接收到的消息：" + new String(message.getBody()) +</span><br><span class="line">                    "接收队列：" + queueName + "绑定键：" + message.getEnvelope().getRoutingKey());</span><br><span class="line">            System.out.println("好好好");</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("Q1取消消息");</span><br><span class="line">        };</span><br><span class="line">        channel.basicConsume(queueName, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>消费者2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class ReceiverTopic2 {</span><br><span class="line">    public static final String EXCHANGE_NAME = "topic";</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, "topic");</span><br><span class="line">        String queueName = "Q2";</span><br><span class="line">        channel.queueDeclare(queueName, false, false, false, null); // 不持久化，不共享，不自动删除，无参数</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, "*.*.rabbit");</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, "lazy.#");</span><br><span class="line"></span><br><span class="line">        System.out.println("Q2等待接收消息");</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println("Q2接收到的消息：" + new String(message.getBody()) +</span><br><span class="line">                    "接收队列：" + queueName + "绑定键：" + message.getEnvelope().getRoutingKey());</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("Q2取消消息");</span><br><span class="line">        };</span><br><span class="line">        channel.basicConsume(queueName, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>生产者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public class EmitTopic {</span><br><span class="line">    public static final String EXCHANGE_NAME = "topic";</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; bindingKeyMap = new HashMap&lt;&gt;();</span><br><span class="line">        bindingKeyMap.put("quick.orange.rabbit","被队列Q1Q2接收到");</span><br><span class="line">        bindingKeyMap.put("lazy.orange.elephant'","被队列Q1Q2接收到");</span><br><span class="line">        bindingKeyMap.put("quick.orange.fox","被队列Ql接收到");</span><br><span class="line">        bindingKeyMap.put("lazy.brown.fox","被队列Q2接收到");</span><br><span class="line">        bindingKeyMap.put("lazy.pink.rabbit","虽然满足两个绑定但只被队列Q2接收一次");</span><br><span class="line">        bindingKeyMap.put("quick.brown.fox","不匹配任何绑定不会被任何队列接收到会被丢弃");</span><br><span class="line">        bindingKeyMap.put("quick.orange.male.rabbit","是四个单词不匹配任何绑定会被丢弃");</span><br><span class="line">        bindingKeyMap.put("lazy.orange.male.rabbit","是四个单词但匹配Q2");</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) {</span><br><span class="line">            String routineKey = bindingKeyEntry.getKey();</span><br><span class="line">            String message = bindingKeyEntry.getKey();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routineKey,null, message.getBytes("UTF-8"));</span><br><span class="line">            System.out.println("生产者发出消息：" + message);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong><br>当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像<strong>fanout</strong>了。<br>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是<strong>direct</strong>了</p>
<h2 id="6-死信队列"><a href="#6-死信队列" class="headerlink" title="6. 死信队列"></a>6. 死信队列</h2><h3 id="6-1-死信的概念"><a href="#6-1-死信的概念" class="headerlink" title="6.1 死信的概念"></a>6.1 死信的概念</h3><p>何为死信？顾名思义就是无法被消费的消息。一般来说，生产者 将消息投递到broker或者直接到queue里，消费者从中取出消息进行消费，但有时由于某些原因导致消息不能被消费，这样的消息如果没有后续的处理就会变成死信，那么存放死信的队列就是死信队列。</p>
<p><strong>应用场景：</strong></p>
<p>为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</p>
<h3 id="6-2-产生死信的原因"><a href="#6-2-产生死信的原因" class="headerlink" title="6.2 产生死信的原因"></a>6.2 产生死信的原因</h3><ol>
<li>消息TTL过期</li>
<li>队列达到最大长度</li>
<li>消息被拒绝并且requeue = false（不予重新入队）</li>
</ol>
<h3 id="6-3-死信实战"><a href="#6-3-死信实战" class="headerlink" title="6.3 死信实战"></a>6.3 死信实战</h3><h4 id="6-3-1-代码架构图"><a href="#6-3-1-代码架构图" class="headerlink" title="6.3.1 代码架构图"></a>6.3.1 代码架构图</h4><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107185524304.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240107185524304.png" alt="image-20240107185524304"></a></p>
<p><strong>死信队列代码演示</strong>：</p>
<p>Consumer01:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Consumer01 {</span><br><span class="line">    // 普通交换机名称</span><br><span class="line">    public static final String NORMAL_EXCHANGE = "normal_exchange";</span><br><span class="line">    // 死信交换机名称</span><br><span class="line">    public static final String DEAD_EXCHANGE = "dead_exchange";</span><br><span class="line">    // 普通队列名称</span><br><span class="line">    public static final String NORMAL_QUEUE = "normal_queue";</span><br><span class="line">    // 死信队列名称</span><br><span class="line">    public static final String DEAD_QUEUE = "dead_queue";</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, "direct");</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, "direct");</span><br><span class="line">        // 声明普通队列</span><br><span class="line">        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();</span><br><span class="line">        // 过期时间</span><br><span class="line">        // arguments.put("x-message-ttl", 10000);</span><br><span class="line">        // 正常队列设置死信交换机</span><br><span class="line">        arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);</span><br><span class="line">        // 设置死信routingKey</span><br><span class="line">        arguments.put("x-dead-letter-routing-key", "lisi");</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, false, false, false, null);</span><br><span class="line">        // 声明死信队列</span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, "zhangsan");</span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, "lisi");</span><br><span class="line">        System.out.println("等待接收消息");</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println("consumer01接收的消息：" + new String(message.getBody()));</span><br><span class="line"></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("Q1取消消息");</span><br><span class="line">        };</span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE, true, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Producer:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * 死信队列之生产者</span><br><span class="line"> */</span><br><span class="line">public class Producer {</span><br><span class="line">    // 普通交换机名称</span><br><span class="line">    public static final String NORMAL_EXCHANGE = "normal_exchange";</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        //死信消息 设置TTL时间</span><br><span class="line">        AMQP.BasicProperties properties = new AMQP.BasicProperties()</span><br><span class="line">                .builder().expiration("10000").build();</span><br><span class="line"></span><br><span class="line">        // 延迟消息</span><br><span class="line">        for (int i = 0;i &lt; 10;i++) {</span><br><span class="line">            String message = i + "";</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, "zhangsan", null, message.getBytes());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Consumer02:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Consumer02 {</span><br><span class="line">    // 死信队列名称</span><br><span class="line">    public static final String DEAD_QUEUE = "dead_queue";</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println("consumer02等待接收消息");</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println("consumer02接收的消息：" + new String(message.getBody()));</span><br><span class="line"></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("C2取消消息");</span><br><span class="line">        };</span><br><span class="line">        channel.basicConsume(DEAD_QUEUE, true, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="6-3-2-消息TTL过期"><a href="#6-3-2-消息TTL过期" class="headerlink" title="6.3.2 消息TTL过期"></a>6.3.2 消息TTL过期</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 方式1</span><br><span class="line">//死信消息 设置TTL时间</span><br><span class="line">AMQP.BasicProperties properties = new AMQP.BasicProperties()</span><br><span class="line">        .builder().expiration("10000").build();</span><br><span class="line">// 方式2</span><br><span class="line">Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();</span><br><span class="line">// 过期时间</span><br><span class="line">arguments.put("x-message-ttl", 10000);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="6-3-3-队列达到最大长度"><a href="#6-3-3-队列达到最大长度" class="headerlink" title="6.3.3 队列达到最大长度"></a>6.3.3 队列达到最大长度</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public class Consumer01 {</span><br><span class="line">    // 普通交换机名称</span><br><span class="line">    public static final String NORMAL_EXCHANGE = "normal_exchange";</span><br><span class="line">    // 死信交换机名称</span><br><span class="line">    public static final String DEAD_EXCHANGE = "dead_exchange";</span><br><span class="line">    // 普通队列名称</span><br><span class="line">    public static final String NORMAL_QUEUE = "normal_queue";</span><br><span class="line">    // 死信队列名称</span><br><span class="line">    public static final String DEAD_QUEUE = "dead_queue";</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException {</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        // 声明死信和普通交换机，类型为direct</span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        // 声明普通队列</span><br><span class="line">        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();</span><br><span class="line">        // 过期时间</span><br><span class="line">        // arguments.put("x-message-ttl", 10000);</span><br><span class="line">        // 正常队列设置死信交换机</span><br><span class="line">        arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);</span><br><span class="line">        // 设置死信routingKey</span><br><span class="line">        arguments.put("x-dead-letter-routing-key", "lisi");</span><br><span class="line">        // 设置正常队列的长度限制</span><br><span class="line">        arguments.put("x-max-length", 6);</span><br><span class="line"></span><br><span class="line">        // 声明普通队列</span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, false, false, false, null);</span><br><span class="line">        // 声明死信队列</span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, "zhangsan");</span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, "lisi");</span><br><span class="line">        System.out.println("consumer01等待接收消息");</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println("consumer01接收的消息：" + new String(message.getBody()));</span><br><span class="line"></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("C1取消消息");</span><br><span class="line">        };</span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE, true, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="6-3-4-消息被拒"><a href="#6-3-4-消息被拒" class="headerlink" title="6.3.4 消息被拒"></a>6.3.4 消息被拒</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">    String msg = new String(message.getBody(), "UTF-8");</span><br><span class="line">    if (msg.equals("info5")) {</span><br><span class="line">        System.out.println(msg + "：此消息是被拒绝的");</span><br><span class="line">        channel.basicReject(message.getEnvelope().getDeliveryTag(), false); //拒绝此消息并不放回普通队列</span><br><span class="line">    }</span><br><span class="line">    System.out.println("consumer01接收的消息：" + new String(message.getBody()));</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-延迟队列（死信队列实现）"><a href="#7-延迟队列（死信队列实现）" class="headerlink" title="7. 延迟队列（死信队列实现）"></a>7. 延迟队列（死信队列实现）</h2><h3 id="7-1-延迟队列的概念"><a href="#7-1-延迟队列的概念" class="headerlink" title="7.1 延迟队列的概念"></a>7.1 延迟队列的概念</h3><p>延迟队列的内部是有序的，最重要的属性体现在它的延迟属性上。延迟队列就是用来存放需要在指定时间被处理的元素的队列。</p>
<h3 id="7-2-延迟队列的使用场景"><a href="#7-2-延迟队列的使用场景" class="headerlink" title="7.2 延迟队列的使用场景"></a>7.2 延迟队列的使用场景</h3><ol>
<li>订单在十分钟内未支付则取消</li>
<li>新创建的店铺，如果在十天内未上传过商品，则自动发送消息提醒</li>
<li>用户注册成功后，如果三天内没有登录则发消息提醒</li>
<li>用户发起退款，如果三天内没有得到处理则通知相关运用那个人员</li>
<li>预定会议后，在预定时间前十分钟通知参会人员参加会议</li>
</ol>
<h3 id="7-3-延迟队列的代码实现（整合Spring-Boot）"><a href="#7-3-延迟队列的代码实现（整合Spring-Boot）" class="headerlink" title="7.3 延迟队列的代码实现（整合Spring Boot）"></a>7.3 延迟队列的代码实现（整合Spring Boot）</h3><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240108144407870.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240108144407870.png" alt="image-20240108144407870"></a></p>
<p>TtlQueueConfig:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Configuration</span><br><span class="line">public class TtlQueueConfig {</span><br><span class="line">    // 普通交换机名称</span><br><span class="line">    public static final String X_EXCHANGE = "X";</span><br><span class="line">    // 死信交换机名</span><br><span class="line">    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";</span><br><span class="line">    // 普通队列名称</span><br><span class="line">    public static final String QUEUE_A = "QA";</span><br><span class="line">    public static final String QUEUE_B = "QB";</span><br><span class="line">    // 死信队列名称</span><br><span class="line">    public static final String DEAD_LETTER_QUEUE = "QD";</span><br><span class="line"></span><br><span class="line">    // 声明xExchange</span><br><span class="line">    @Bean("xExchange")</span><br><span class="line">    public DirectExchange xExchange() {</span><br><span class="line">        return new DirectExchange(X_EXCHANGE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 声明yExchange</span><br><span class="line">    @Bean("yExchange")</span><br><span class="line">    public DirectExchange yExchange() {</span><br><span class="line">        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明普通队列  要有ttl 为10s</span><br><span class="line">    @Bean("queueA")</span><br><span class="line">    public Queue queueA() {</span><br><span class="line">        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();</span><br><span class="line">        // 设置死信交换机</span><br><span class="line">        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        arguments.put("x-dead-letter-routing-key", "YD");</span><br><span class="line">        arguments.put("x-message-ttl", 10000);</span><br><span class="line">        return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明普通队列  要有ttl 为40s</span><br><span class="line">    @Bean("queueB")</span><br><span class="line">    public Queue queueB() {</span><br><span class="line">        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);</span><br><span class="line">        // 设置死信交换机</span><br><span class="line">        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        arguments.put("x-dead-letter-routing-key", "YD");</span><br><span class="line">        arguments.put("x-message-ttl", 40000);</span><br><span class="line">        return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明死信队列  要有ttl 为40s</span><br><span class="line">    @Bean("queueD")</span><br><span class="line">    public Queue queueD() {</span><br><span class="line">        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明队列 QA 绑定 X 交换机</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding queueABindingX(@Qualifier("queueA") Queue queueA,</span><br><span class="line">                                  @Qualifier("xExchange") DirectExchange xExchange) {</span><br><span class="line">        return BindingBuilder.bind(queueA).to(xExchange).with("XA");</span><br><span class="line">    }</span><br><span class="line">    //声明队列 QB 绑定 X 交换机</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding queueBBindingX(@Qualifier("queueB") Queue queueB,</span><br><span class="line">                                  @Qualifier("xExchange") DirectExchange xExchange) {</span><br><span class="line">        return BindingBuilder.bind(queueB).to(xExchange).with("XB");</span><br><span class="line">    }</span><br><span class="line">    //声明队列 QD 绑定 Y 交换机</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding queueDBindingX(@Qualifier("queueD") Queue queueD,</span><br><span class="line">                                  @Qualifier("yExchange") DirectExchange yExchange) {</span><br><span class="line">        return BindingBuilder.bind(queueD).to(yExchange).with("YD");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>DeadLetterQueueConsumer:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">	@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class DeadLetterQueueConsumer {</span><br><span class="line">    // 接收消息</span><br><span class="line">    @RabbitListener(queues = "QD")</span><br><span class="line">    public void receiveD(Message message, Channel channel)throws Exception {</span><br><span class="line">        String msg = new String(message.getBody());</span><br><span class="line">        log.info("当前时间：{}，收到死信队列的消息：{}", new Date().toString(), msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>SendMessageController:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping("/ttl")</span><br><span class="line">public class SendMessageController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line">    @GetMapping("/sendMsg/{message}")</span><br><span class="line">    public void sendMsg(@PathVariable String message) {</span><br><span class="line">        rabbitTemplate.convertAndSend("X", "XA", "消息来自ttl为10s的队列：" + message);</span><br><span class="line">        rabbitTemplate.convertAndSend("X", "XB", "消息来自ttl为40s的队列：" + message);</span><br><span class="line">        log.info("当前时间：{}，发送一条消息给两个TTL队列：{}", new Date().toString(), message);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-4-延迟队列的优化"><a href="#7-4-延迟队列的优化" class="headerlink" title="7.4 延迟队列的优化"></a>7.4 延迟队列的优化</h3><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240108144310025.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240108144310025.png" alt="image-20240108144310025"></a></p>
<p>新增一个队列QC，绑定关系如上，但不设置TTL。</p>
<p>TtlQueueConfig:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Configuration</span><br><span class="line">public class TtlQueueConfig {</span><br><span class="line">    // 普通交换机名称</span><br><span class="line">    public static final String X_EXCHANGE = "X";</span><br><span class="line">    // 死信交换机名</span><br><span class="line">    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";</span><br><span class="line">    // 普通队列名称</span><br><span class="line">    public static final String QUEUE_A = "QA";</span><br><span class="line">    public static final String QUEUE_B = "QB";</span><br><span class="line">    // 死信队列名称</span><br><span class="line">    public static final String DEAD_LETTER_QUEUE = "QD";</span><br><span class="line">    // 普通队列的名称</span><br><span class="line">    public static final String QUEUE_C = "QC";</span><br><span class="line"></span><br><span class="line">    // 声明QC队列</span><br><span class="line">    @Bean("queueC")</span><br><span class="line">    public Queue queueC(){</span><br><span class="line">        Map&lt;String ,Object&gt; arguments = new HashMap&lt;&gt;(3);</span><br><span class="line">        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE); // 设置死信交换机</span><br><span class="line">        arguments.put("x-dead-routing-key", "YD"); // 设置死信routingKey</span><br><span class="line">        // 设置TTL</span><br><span class="line">        return QueueBuilder.durable().withArguments(arguments).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Binding queueCBindingX(@Qualifier("queueC") Queue queueC,</span><br><span class="line">                                  @Qualifier("xExchange") DirectExchange xExchange) {</span><br><span class="line">        return BindingBuilder.bind(queueC).to(xExchange).with("XC");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 声明xExchange</span><br><span class="line">    @Bean("xExchange")</span><br><span class="line">    public DirectExchange xExchange() {</span><br><span class="line">        return new DirectExchange(X_EXCHANGE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 声明yExchange</span><br><span class="line">    @Bean("yExchange")</span><br><span class="line">    public DirectExchange yExchange() {</span><br><span class="line">        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明普通队列  要有ttl 为10s</span><br><span class="line">    @Bean("queueA")</span><br><span class="line">    public Queue queueA() {</span><br><span class="line">        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();</span><br><span class="line">        // 设置死信交换机</span><br><span class="line">        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        arguments.put("x-dead-letter-routing-key", "YD");</span><br><span class="line">        arguments.put("x-message-ttl", 10000);</span><br><span class="line">        return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明普通队列  要有ttl 为40s</span><br><span class="line">    @Bean("queueB")</span><br><span class="line">    public Queue queueB() {</span><br><span class="line">        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);</span><br><span class="line">        // 设置死信交换机</span><br><span class="line">        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        arguments.put("x-dead-letter-routing-key", "YD");</span><br><span class="line">        arguments.put("x-message-ttl", 40000);</span><br><span class="line">        return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明死信队列  要有ttl 为40s</span><br><span class="line">    @Bean("queueD")</span><br><span class="line">    public Queue queueD() {</span><br><span class="line">        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明队列 QA 绑定 X 交换机</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding queueABindingX(@Qualifier("queueA") Queue queueA,</span><br><span class="line">                                  @Qualifier("xExchange") DirectExchange xExchange) {</span><br><span class="line">        return BindingBuilder.bind(queueA).to(xExchange).with("XA");</span><br><span class="line">    }</span><br><span class="line">    //声明队列 QB 绑定 X 交换机</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding queueBBindingX(@Qualifier("queueB") Queue queueB,</span><br><span class="line">                                  @Qualifier("xExchange") DirectExchange xExchange) {</span><br><span class="line">        return BindingBuilder.bind(queueB).to(xExchange).with("XB");</span><br><span class="line">    }</span><br><span class="line">    //声明队列 QD 绑定 Y 交换机</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding queueDBindingX(@Qualifier("queueD") Queue queueD,</span><br><span class="line">                                  @Qualifier("yExchange") DirectExchange yExchange) {</span><br><span class="line">        return BindingBuilder.bind(queueD).to(yExchange).with("YD");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>SendMessageController:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping("/ttl")</span><br><span class="line">public class SendMessageController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line">    @GetMapping("/sendMsg/{message}")</span><br><span class="line">    public void sendMsg(@PathVariable String message) {</span><br><span class="line">        rabbitTemplate.convertAndSend("X", "XA", "消息来自ttl为10s的队列：" + message);</span><br><span class="line">        rabbitTemplate.convertAndSend("X", "XB", "消息来自ttl为40s的队列：" + message);</span><br><span class="line">        log.info("当前时间：{}，发送一条消息给两个TTL队列：{}", new Date().toString(), message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @GetMapping("/sendExpirationMsg/{message}/{ttlTime}")</span><br><span class="line">    public void sendMsg(@PathVariable String message, @PathVariable String ttlTime){</span><br><span class="line">        rabbitTemplate.convertAndSend("X", "XC", message, msg -&gt; {</span><br><span class="line">            msg.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">            return msg;</span><br><span class="line">        });</span><br><span class="line">        log.info("当前时间：{}，发送一条时长{}毫秒TTL消息给两个TTL队列QC：{}", new Date().toString(), ttlTime, message);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>缺陷</strong>：</p>
<p>如果发送的第一个消息msg1的TTL为20s，第二个消息msg2的TTL为2s，死信队列先收到的是msg1而不是msg2。因为RabbitMQ只会检查第一个消息是否过期如果过期则丢到死信队列，如果第一个消息的诞时时长很而第二个消息的延时时长很短第二个消息并不会优先得到执行。</p>
<h3 id="7-5-延迟队列插件实现"><a href="#7-5-延迟队列插件实现" class="headerlink" title="7.5 延迟队列插件实现"></a>7.5 延迟队列插件实现</h3><p>基于插件的延迟队列的配置类：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Configuration</span><br><span class="line">public class DelayedQueueConfig {</span><br><span class="line">    // 交换机</span><br><span class="line">    public static final String DELAYED_QUEUE_NAME = "delayed.queue";</span><br><span class="line">    // 队列</span><br><span class="line">    public static final String DELAYED_EXCHANGE_NAME = "delayed.exchange";</span><br><span class="line">    // routingKey</span><br><span class="line">    public static final String DELAYED_ROUTINGKEY = "delayed.routingKey";</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue delayedQueue() {</span><br><span class="line">        return new Queue(DELAYED_QUEUE_NAME);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 声明交换机</span><br><span class="line">    @Bean</span><br><span class="line">    public CustomExchange delayedExchange() {</span><br><span class="line">        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();</span><br><span class="line">        arguments.put("x-delayed-type", "direct");</span><br><span class="line">        /**</span><br><span class="line">         * 1.交换机的名称</span><br><span class="line">         * 2.交换机的类型</span><br><span class="line">         * 3.是否需要自动化</span><br><span class="line">         * 4.是否需要自动删除</span><br><span class="line">         */</span><br><span class="line">        return new CustomExchange(DELAYED_EXCHANGE_NAME, "x-delayed-message", true, false);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 绑定交换机和队列</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding delayedQueueBindingDelayedExchange(</span><br><span class="line">            @Qualifier("delayedQueue") Queue delayedQueue,</span><br><span class="line">            @Qualifier("delayedExchange") CustomExchange delayedExchange) {</span><br><span class="line">        return BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTINGKEY).noargs();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>生产者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping("/ttl")</span><br><span class="line">public class SendMessageController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line">    @GetMapping("/sendMsg/{message}")</span><br><span class="line">    public void sendMsg(@PathVariable String message) {</span><br><span class="line">        rabbitTemplate.convertAndSend("X", "XA", "消息来自ttl为10s的队列：" + message);</span><br><span class="line">        rabbitTemplate.convertAndSend("X", "XB", "消息来自ttl为40s的队列：" + message);</span><br><span class="line">        log.info("当前时间：{}，发送一条消息给两个TTL队列：{}", new Date().toString(), message);</span><br><span class="line">    }</span><br><span class="line">	// 发送基于死信队列的延迟消息</span><br><span class="line">    @GetMapping("/sendExpirationMsg/{message}/{ttlTime}")</span><br><span class="line">    public void sendMsg(@PathVariable String message, @PathVariable String ttlTime){</span><br><span class="line">        rabbitTemplate.convertAndSend("X", "XC", message, msg -&gt; {</span><br><span class="line">            msg.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">            return msg;</span><br><span class="line">        });</span><br><span class="line">        log.info("当前时间：{}，发送一条时长{}毫秒TTL消息给两个TTL队列QC：{}", new Date().toString(), ttlTime, message);</span><br><span class="line">    }</span><br><span class="line">	// 发送基于插件的延迟队列的消息</span><br><span class="line">    @GetMapping("/sendDelayMsg/{message}/{delayTime}")</span><br><span class="line">    public void sendMsg(@PathVariable String message, @PathVariable Integer delayTime) {</span><br><span class="line">        rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME,</span><br><span class="line">                DelayedQueueConfig.DELAYED_ROUTINGKEY, message, msg -&gt; {</span><br><span class="line">            // 发送消息的时候 延迟时长 单位ms</span><br><span class="line">            msg.getMessageProperties().setDelay(delayTime);</span><br><span class="line">            return msg;</span><br><span class="line">        });</span><br><span class="line">        log.info("当前时间：{}，发送一条时长{}毫秒的消息给延迟队列delayed.queue:{}", new Date().toString(), delayTime, message);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>消费者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class DelayedQueueConsumer {</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)</span><br><span class="line">    public void receiveDelayQueue(Message message) {</span><br><span class="line">        String msg = new String(message.getBody());</span><br><span class="line">        log.info("当前时间：{}，收到延迟队列的消息：{}", new Date().toString(), msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>延时队列在需要延时处理的场景下非常有用，使用RabbitMQ来实现延时队列可以很好的利用<br>RabbitMQ的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过RabbitMQ集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。<br>当然，延时队列还有很多其它选择，比如利用Java的DelayQueue,利用Redis的set,利用Quartz<br>或者利用kafka的时间轮，这些方式各有特点看需要适用的场景</p>
<h2 id="8-发布确认高级"><a href="#8-发布确认高级" class="headerlink" title="8. 发布确认高级"></a>8. 发布确认高级</h2><p>RabbitMQ会由于某些原因导致重启，那么生产者投递的消息无法被消费导致消息丢失，需要手动处理和恢复。在RabbitMQ集群不可用的时候，怎么处理无法投递的消息呢？</p>
<h3 id="8-1-发布确认Spring-Boot版本"><a href="#8-1-发布确认Spring-Boot版本" class="headerlink" title="8.1 发布确认Spring Boot版本"></a>8.1 发布确认Spring Boot版本</h3><h4 id="8-1-1-确认机制方案"><a href="#8-1-1-确认机制方案" class="headerlink" title="8.1.1 确认机制方案"></a>8.1.1 确认机制方案</h4><p>生产者发送消息给交换机，但交换机无法接受消息，则把消息放在缓存中。当交换机能收到消息时通过定时任务把缓存中的消息重新投递到交换机，并清除缓存中的消息。</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112141820874.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112141820874.png" alt="image-20240112141820874"></a></p>
<h4 id="8-1-2-代码结构图"><a href="#8-1-2-代码结构图" class="headerlink" title="8.1.2 代码结构图"></a>8.1.2 代码结构图</h4><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112142400747.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112142400747.png" alt="image-20240112142400747"></a></p>
<h4 id="8-1-3-编写配置类（注意一定要加上-Configuration注解）"><a href="#8-1-3-编写配置类（注意一定要加上-Configuration注解）" class="headerlink" title="8.1.3 编写配置类（注意一定要加上@Configuration注解）"></a>8.1.3 编写配置类（注意一定要加上@Configuration注解）</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line"> * 发布确认高级配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class ConfirmSeniorConfig {</span><br><span class="line">    // 交换机</span><br><span class="line">    public static final String CONFIRM_EXCHANGE_NAME = "confirm_exchange";</span><br><span class="line">    // 队列</span><br><span class="line">    public static final String CONFIRM_QUEUE_NAME = "confirm_queue";</span><br><span class="line">    // routingKey</span><br><span class="line">    public static final String CONFIRM_ROUTING_KEY = "key1";</span><br><span class="line"></span><br><span class="line">    // 声明交换机</span><br><span class="line">    @Bean("confirmExchange")</span><br><span class="line">    public DirectExchange confirmExchange() {</span><br><span class="line">        return new DirectExchange(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 声明队列</span><br><span class="line">    @Bean("confirmQueue")</span><br><span class="line">    public Queue confirmQueue() {</span><br><span class="line">        return new Queue(CONFIRM_QUEUE_NAME);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 绑定交换机和队列</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding queueBindingExchange(@Qualifier("confirmQueue") Queue confirmQueue,</span><br><span class="line">                                        @Qualifier("confirmExchange") DirectExchange confirmExchange) {</span><br><span class="line">        return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>生产者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">/**</span><br><span class="line"> * 发布确认高级生产者</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">@RequestMapping("/confirmSenior")</span><br><span class="line">public class ProducerController {</span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    // 发消息</span><br><span class="line">    @GetMapping("/sendMessage/{message}")</span><br><span class="line">    public void sendMessage(@PathVariable String message) {</span><br><span class="line">        CorrelationData correlationData = new CorrelationData("1");</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmSeniorConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">                ConfirmSeniorConfig.CONFIRM_ROUTING_KEY, message, correlationData);</span><br><span class="line">        log.info("发送消息内容为{}", message);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>消费者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">/**</span><br><span class="line"> * 发布确认高级消费者</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class ConfirmSeniorConsumer {</span><br><span class="line">     @RabbitListener(queues = ConfirmSeniorConfig.CONFIRM_QUEUE_NAME)</span><br><span class="line">    public void receiveConfirmMessage(Message message) {</span><br><span class="line">         String msg = new String(message.getBody());</span><br><span class="line">         log.info("接受到的队列confirm.queue的消息：{}", msg);</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="8-1-4-回调接口"><a href="#8-1-4-回调接口" class="headerlink" title="8.1.4 回调接口"></a>8.1.4 回调接口</h4><p>当生产者发送消息不能被交换机接收时，会出发回调接口的方法。谁发送消息谁实现回调接口。</p>
<p><strong>调用回调方法的时机：</strong></p>
<ol>
<li><p>发消息给交换机，交换机接收到了 =&gt; 触发回调</p>
<p> 重写方法各个形参的代表意思</p>
<ol>
<li>correlationData保存回调消息的id和相关信息</li>
<li>交换机收到消息 true</li>
<li>cause 原因</li>
</ol>
</li>
<li><p>发消息给交换机，交换机接收失败 =&gt; 触发回调</p>
<ol>
<li>correlationData 保存回调消息的id和相关信息</li>
<li>交换机收到消息 =&gt; false</li>
<li>cause 接收消息失败的原因</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class MyCallBack implements RabbitTemplate.ConfirmCallback {</span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    // 将重写的方法注入到RabbitTemplate.ConfirmCallback这个接口中</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() {</span><br><span class="line">        rabbitTemplate.setConfirmCallback(this);</span><br><span class="line">    }</span><br><span class="line">    /**</span><br><span class="line">     * 交换机确认回到方法</span><br><span class="line">     * @param correlationData</span><br><span class="line">     * @param ack</span><br><span class="line">     * @param cause</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void confirm(CorrelationData correlationData, boolean ack, String cause) {</span><br><span class="line">        String id = correlationData != null ? correlationData.getId() : "";</span><br><span class="line">        if (ack) {</span><br><span class="line">            log.info("交换机已经收到Id为：{}的消息", id);</span><br><span class="line">        } else {</span><br><span class="line">            log.info("交换机还未收到Id为：{}消息，由于原因：{}", id, cause );</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li><p>实现RabbitTemplate.ConfirmCallback接口时一定要将重写的confirm方法重新注入到RabbitTemplate.ConfirmCallback接口中，不然重写的方法不会被自动调用</p>
<ol>
<li>注意注入的顺序 实现RabbitTemplate.ConfirmCallback接口的类先注入，再是RabbitTemplate，最后才是重写的Confirm方法</li>
</ol>
</li>
<li><p>调用回调接口要在配置文件中，添加</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">spring.rabbitmq.publisher-confirm-type=correlated</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112153925736.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112153925736.png" alt="image-20240112153925736"></a></p>
<p>SIMPLE模式具有关闭信道channel的风险</p>
</li>
<li><p>如果不重写回调接口，交换机就不知道消息接收成功与否，这样子也难以将发送失败的消息给<strong>临时</strong>存储起来</p>
</li>
<li><p>生产者发送消息时可以指定发送消息的id</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">CorrelationData correlationData = new CorrelationData("1");</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>交换机接收成功：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112155219600.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112155219600.png" alt="image-20240112155219600"></a></p>
<p>交换机接收失败：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112155305310.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112155305310.png" alt="image-20240112155305310"></a></p>
<p>如果生产者发送的消息是这样的：（即发送一个正确routingKey的消息和发送一个错误routingKey的消息）。这样子的话队列接收到第一个信息，但未接收到第二个消息，并且队列不会应答，只有交换机确认了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">// 发消息</span><br><span class="line">@GetMapping("/sendMessage/{message}")</span><br><span class="line">public void sendMessage(@PathVariable String message) {</span><br><span class="line">    CorrelationData correlationData1 = new CorrelationData("1");</span><br><span class="line">    rabbitTemplate.convertAndSend(ConfirmSeniorConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">            ConfirmSeniorConfig.CONFIRM_ROUTING_KEY, message, correlationData1);</span><br><span class="line">    log.info("发送消息内容为{}", message);</span><br><span class="line"></span><br><span class="line">    CorrelationData correlationData2 = new CorrelationData("2");</span><br><span class="line">    rabbitTemplate.convertAndSend(ConfirmSeniorConfig.CONFIRM_EXCHANGE_NAME,</span><br><span class="line">            ConfirmSeniorConfig.CONFIRM_ROUTING_KEY + "2", message, correlationData2);</span><br><span class="line">    log.info("发送消息内容为{}", message);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>结果如下：</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112160341516.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112160341516.png" alt="image-20240112160341516"></a></p>
<h3 id="8-2-回退消息"><a href="#8-2-回退消息" class="headerlink" title="8.2 回退消息"></a>8.2 回退消息</h3><h4 id="8-1-1-Mandatory参数"><a href="#8-1-1-Mandatory参数" class="headerlink" title="8.1.1 Mandatory参数"></a>8.1.1 Mandatory参数</h4><p>在仅开启生产者确认机制的情况下，交换机接收到消息后会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息则会被直接丢弃，而生产者是不知道消息被丢弃了。</p>
<h5 id="如何回退消息？-实现RabbitTemplate-ReturnsCallback接口的returnedMessage回退方法"><a href="#如何回退消息？-实现RabbitTemplate-ReturnsCallback接口的returnedMessage回退方法" class="headerlink" title="如何回退消息？ => 实现RabbitTemplate.ReturnsCallback接口的returnedMessage回退方法"></a>如何回退消息？ =&gt; 实现RabbitTemplate.ReturnsCallback接口的returnedMessage回退方法</h5><ul>
<li><p>在配置文件中添加如下配置，开启消息回退。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">spring.rabbitmq.publisher-returns=true</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>实现RabbitTemplate.ReturnsCallback接口的回调方法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class MyCallBack implements RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnsCallback {</span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    // 将重写的方法注入到RabbitTemplate.ConfirmCallback这个接口中</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() {</span><br><span class="line">        rabbitTemplate.setConfirmCallback(this);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    /**</span><br><span class="line">     * 交换机确认消息的回调方法（不管消息是否接收成功都会调用这个方法）</span><br><span class="line">     * @param correlationData</span><br><span class="line">     * @param ack</span><br><span class="line">     * @param cause</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void confirm(CorrelationData correlationData, boolean ack, String cause) {</span><br><span class="line">        String id = correlationData != null ? correlationData.getId() : "";</span><br><span class="line">        if (ack) {</span><br><span class="line">            log.info("交换机已经收到Id为：{}的消息", id);</span><br><span class="line">        } else {</span><br><span class="line">            log.info("交换机还未收到Id为：{}消息，由于原因：{}", id, cause );</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 回退方法 （在消息在传递的过程中不可到达目的地时将消息返回给生产者）</span><br><span class="line">    @Override</span><br><span class="line">    public void returnedMessage(ReturnedMessage returnedMessage) {</span><br><span class="line">        log.info("消息{}，被交换机{}退回，回退原因：{}，路由key：{}", returnedMessage.getMessage(),</span><br><span class="line">                returnedMessage.getExchange(), returnedMessage.getReplyText(), returnedMessage.getRoutingKey());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>重现发送消息发现并<strong>没有调用回退方法</strong>，因为未把重写的回退方法重新注入至那个实现的接口</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112162605950.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112162605950.png" alt="image-20240112162605950"></a></p>
</li>
</ul>
<p> 重新注入就好了：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@PostConstruct</span><br><span class="line">public void init() {</span><br><span class="line">    rabbitTemplate.setConfirmCallback(this);</span><br><span class="line">    rabbitTemplate.setReturnsCallback(this);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>成功示例：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112163622746.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112163622746.png" alt="image-20240112163622746"></a></p>
<p>完整代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class MyCallBack implements RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnsCallback {</span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    // 将重写的方法注入到RabbitTemplate.ConfirmCallback这个接口中</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() {</span><br><span class="line">        rabbitTemplate.setConfirmCallback(this);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(this);</span><br><span class="line">    }</span><br><span class="line">    /**</span><br><span class="line">     * 交换机确认消息的回调方法（不管消息是否接收成功都会调用这个方法）</span><br><span class="line">     * @param correlationData</span><br><span class="line">     * @param ack</span><br><span class="line">     * @param cause</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void confirm(CorrelationData correlationData, boolean ack, String cause) {</span><br><span class="line">        String id = correlationData != null ? correlationData.getId() : "";</span><br><span class="line">        if (ack) {</span><br><span class="line">            log.info("交换机已经收到Id为：{}的消息", id);</span><br><span class="line">        } else {</span><br><span class="line">            log.info("交换机还未收到Id为：{}消息，由于原因：{}", id, cause );</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 回退方法 （在消息在传递的过程中不可到达目的地时将消息返回给生产者）</span><br><span class="line">    @Override</span><br><span class="line">    public void returnedMessage(ReturnedMessage returnedMessage) {</span><br><span class="line">        log.info("消息{}，被交换机{}退回，回退原因：{}，路由key：{}", returnedMessage.getMessage(),</span><br><span class="line">                returnedMessage.getExchange(), returnedMessage.getReplyText(), returnedMessage.getRoutingKey());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-3-备份交换机"><a href="#8-3-备份交换机" class="headerlink" title="8.3 备份交换机"></a>8.3 备份交换机</h3><h4 id="8-3-1-代码架构图"><a href="#8-3-1-代码架构图" class="headerlink" title="8.3.1 代码架构图"></a>8.3.1 代码架构图</h4><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112163156524.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112163156524.png" alt="image-20240112163156524"></a></p>
<h4 id="8-3-2-修改配置类"><a href="#8-3-2-修改配置类" class="headerlink" title="8.3.2 修改配置类"></a>8.3.2 修改配置类</h4><p>在配置类中多加一个备份交换机、备份队列、报警队列、备份消费者（可不写）和报警消费者。<strong>注意</strong>还要说明确认交换机无法接收消息时，需将消息<strong>转发给备份交换机</strong>。并把之前创建的确认交换机给删除，因为它的信息被修改了。</p>
<p>结果分析：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112170609876.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source/_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112170609876.png" alt="image-20240112170609876"></a></p>
<h3 id="8-3-3-总结"><a href="#8-3-3-总结" class="headerlink" title="8.3.3 总结"></a>8.3.3 总结</h3><p><strong>Mandatory参数和备份交换机可以一起使用，但同时开启Mandatory和备份交换机，消息会到哪里？</strong></p>
<p>实验结果：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112170909234.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112170909234.png" alt="image-20240112170909234"></a></p>
<p>老师的实验结果是备份交换机优先级更高，但是我的结果却是消息被回退了和老师不一致。（根据自己的实际场景来）</p>
<h2 id="9-RabbitMQ其他知识点"><a href="#9-RabbitMQ其他知识点" class="headerlink" title="9. RabbitMQ其他知识点"></a>9. RabbitMQ其他知识点</h2><h3 id="9-1-幂等性"><a href="#9-1-幂等性" class="headerlink" title="9.1 幂等性"></a>9.1 幂等性</h3><h4 id="9-1-1-概念"><a href="#9-1-1-概念" class="headerlink" title="9.1.1 概念"></a>9.1.1 概念</h4><p>什么是幂等性？幂等性指的是无论执行多少次同样的操作，结果都是一致的。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p>
<h4 id="9-1-2-消息重复消费"><a href="#9-1-2-消息重复消费" class="headerlink" title="9.1.2 消息重复消费"></a>9.1.2 消息重复消费</h4><p>消费者在消费MQ中的消息时，MQ已经把消息发给消费者，但消费者在给MQ返回ack时网络中断，故MQ未收到确认消息，导致该消息会在网络正常时再次发给消费者，导致消费者消费了重复的消息。</p>
<h4 id="9-1-3-解决思路1（乐观锁）"><a href="#9-1-3-解决思路1（乐观锁）" class="headerlink" title="9.1.3 解决思路1（乐观锁）"></a>9.1.3 解决思路1（乐观锁）</h4><p>MQ消费者的幂等性的解决一般使用全局ID或者写个唯一标识比如时间戳或者UUID或者订单消费者消费MQ中的消息也可利用MQ的该id来判断，或者可按自己的规侧则生成一个全局唯一id,每次消费消息时用该d先判断该消息是否已消费过。</p>
<h4 id="9-1-4-解决思路2-消费端的幂等性保障"><a href="#9-1-4-解决思路2-消费端的幂等性保障" class="headerlink" title="9.1.4 解决思路2 消费端的幂等性保障"></a>9.1.4 解决思路2 消费端的幂等性保障</h4><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作：a.唯一ID+指纹码机制，利用数据库主键去重，b.利用redis的原子性去实现</p>
<h4 id="9-1-5-解决思路3-唯一ID-指纹码机制"><a href="#9-1-5-解决思路3-唯一ID-指纹码机制" class="headerlink" title="9.1.5 解决思路3 唯一ID+指纹码机制"></a>9.1.5 解决思路3 唯一ID+指纹码机制</h4><p>指纹码：我们的一些规侧或者时间戳加别的服务给到的唯一信息码，它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个d是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>
<h4 id="9-1-6-解决思路4-Redis原子性（推荐）"><a href="#9-1-6-解决思路4-Redis原子性（推荐）" class="headerlink" title="9.1.6 解决思路4 Redis原子性（推荐）"></a>9.1.6 解决思路4 Redis原子性（推荐）</h4><p>利用redis执行setnx命令，天然具有幂等性。从而实现不重复消费</p>
<h3 id="9-2-优先级队列"><a href="#9-2-优先级队列" class="headerlink" title="9.2 优先级队列"></a>9.2 优先级队列</h3><p>优先级队列的优先级范围为0~255，越大越先执行</p>
<h4 id="9-2-1-使用场景"><a href="#9-2-1-使用场景" class="headerlink" title="9.2.1 使用场景"></a>9.2.1 使用场景</h4><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如<br>果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tm商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用ds来存放的定时轮询，大家都陈知道redis只能用List做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用RabbitMQ进行改造和优化如果发现是大客户的订单给一个相对比较高的优先级，否则就是默认优先级。</p>
<h4 id="9-2-2-如何添加优先级队列"><a href="#9-2-2-如何添加优先级队列" class="headerlink" title="9.2.2 如何添加优先级队列"></a>9.2.2 如何添加优先级队列</h4><ol>
<li><p>控制台添加</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112193513308.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112193513308.png" alt="image-20240112193513308"></a></p>
</li>
<li><p>队列中代码添加优先级</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112193653703.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112193653703.png" alt="image-20240112193653703"></a></p>
</li>
<li><p>消息中代码添加优先级</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112193711040.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112193711040.png" alt="image-20240112193711040"></a></p>
</li>
</ol>
<p> 生产者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">/**</span><br><span class="line"> * 生产者发消息</span><br><span class="line"> * @author 17653</span><br><span class="line"> */</span><br><span class="line">public class Producer1 {</span><br><span class="line">    // 队列名称</span><br><span class="line">    public static final String QUEUE_NAME = "hello";</span><br><span class="line"></span><br><span class="line">    // 发消息</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException {</span><br><span class="line">        // 创建工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        // 设置工厂 IP 连接RabbitMQ的队列</span><br><span class="line">        factory.setHost("localhost");</span><br><span class="line">        // 用户名和密码</span><br><span class="line">        factory.setUsername("guest");</span><br><span class="line">        factory.setPassword("guest");</span><br><span class="line">        // 获取信道</span><br><span class="line">        // 创建连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        // 获取信道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /**</span><br><span class="line">         * 生成一个队列</span><br><span class="line">         * 1.队列名称</span><br><span class="line">         * 2.队列中消息是否持久化（存在磁盘中） 默认情况下消息存在内容中</span><br><span class="line">         * 3.该队列是否只供一个消费者消费 （是否进行消息共享）true：可以多个消费者消费  false：只能一个消费者消费</span><br><span class="line">         * 4.是否自动删除 最后一个消费者端开连接以后该队一句是否自动删除true自动删除false不自动删除</span><br><span class="line">         * 5.其它参数</span><br><span class="line">         */</span><br><span class="line">        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();</span><br><span class="line">        arguments.put("x-max-priority", 10); // 官方允许是0~255之间 此处优先级上限为10，防止浪费CPU和内存</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, false, false, false, arguments);</span><br><span class="line">        // 发消息</span><br><span class="line">        for (int i = 1;i &lt; 11;i++) {</span><br><span class="line">            String message = "info" + i;</span><br><span class="line">            if (i == 5) {</span><br><span class="line">                AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(5).build();</span><br><span class="line">                channel.basicPublish("", QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">            } else {</span><br><span class="line">                channel.basicPublish("", QUEUE_NAME, null, message.getBytes());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        /**</span><br><span class="line">         * 发送一个消费</span><br><span class="line">         * 1.发送到哪个交换机</span><br><span class="line">         * 2.路由的Ky值是哪个 本次是队列的名称</span><br><span class="line">         * 3.其它参数信息</span><br><span class="line">         * 4.发送消息的本体</span><br><span class="line">         */</span><br><span class="line">        System.out.println("消息发送完毕");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>消费者：（消费者并没有任何改变，以前该怎么接收就怎么接收）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">public class Consumer1 {</span><br><span class="line">    // 队列的名称</span><br><span class="line">    public static final String QUEUE_NAME = "hello";</span><br><span class="line">    // 接收消息</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException {</span><br><span class="line">        // 创建连接工厂</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost("localhost");</span><br><span class="line">        factory.setUsername("guest");</span><br><span class="line">        factory.setPassword("guest");</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        // 创建信道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明 接收消息</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; {</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        // 声明 取消消息时的回调</span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; {</span><br><span class="line">            System.out.println("消息消费被中断");</span><br><span class="line">        };</span><br><span class="line">        /**</span><br><span class="line">         * 消费者消费信息</span><br><span class="line">         * 1.消费哪个队列</span><br><span class="line">         * 2.消费成功后是否要应答</span><br><span class="line">         * 3.消费者未成功消费的回调</span><br><span class="line">         * 4.消费者取消消费的回调</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">         channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结果如下：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112195546555.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112195546555.png" alt="image-20240112195546555"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112195628503.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112195628503.png" alt="image-20240112195628503"></a></p>
<p><strong>注意事项：</strong></p>
<p>要让队列实现优先级需要做的事情有如下事情：队列需要设置为优先级队列，消息需要设置消息的优先<br>级，消费者需要等待消息已经发送到队列中才去消费，因为这样才有机会对消息进行排序</p>
<h3 id="9-3-惰性队列"><a href="#9-3-惰性队列" class="headerlink" title="9.3 惰性队列"></a>9.3 惰性队列</h3><p>惰性队列：消息保存在内存中还是磁盘中</p>
<p>正常情况：消息保存在内存中</p>
<p>惰性队列：消息保存在磁盘中，消费速度慢</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>RabbitMQ从3.6.0版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因（比如消费者下线、宕机亦或者是由于维护而关闭等）而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。默认情况下，当生产者将消息发送到RabbitMQ的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然RabbitMQ的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。</p>
<p>（消费者宕机导致大量消息无非消费全部堆积在队列中，这时可以用惰性队列）</p>
<h4 id="9-3-1-两种模式"><a href="#9-3-1-两种模式" class="headerlink" title="9.3.1 两种模式"></a>9.3.1 两种模式</h4><p>队列具有两种模式：default和lazy。</p>
<p>模式即为惰性队列的模式，可以通过调用channel.queue Declare方法的时候在参数中设置，也可以通过<br>Policy的方式设置，如果一个队列同时使用这两种方式设置的话，那么Policy的方式具备更高的优先级。<br>如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>
<p>在队列声明的时候可以通过x-queue-mode”参数来设置队列的模式，取值为”default’和azy’。下面示<br>例中演示了一个惰性队列的声明细节：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">Map&lt;String,Object&gt;args new HashMap&lt;String,Object&gt;()</span><br><span class="line">args.put("x-queue-mode","lazy");</span><br><span class="line">channel.queueDeclare("myqueue",false,false,false,args);</span><br></pre></td></tr></tbody></table></figure>

<p>或者在控制台设置：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112200747454.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112200747454.png" alt="image-20240112200747454"></a></p>
<h4 id="9-3-2-内存开销对比"><a href="#9-3-2-内存开销对比" class="headerlink" title="9.3.2 内存开销对比"></a>9.3.2 内存开销对比</h4><p>在发送一百万条消息，每条消息大概占1KB的情况下，普通队列占用内存1.2GB，而惰性队列仅仅占用1.5MB</p>
<h2 id="10-RabbitMQ集群"><a href="#10-RabbitMQ集群" class="headerlink" title="10. RabbitMQ集群"></a>10. RabbitMQ集群</h2><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112201328087.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112201328087.png" alt="image-20240112201328087"></a></p>
<h3 id="10-1-搭建Rabbit-MQ集群"><a href="#10-1-搭建Rabbit-MQ集群" class="headerlink" title="10.1 搭建Rabbit MQ集群"></a>10.1 搭建Rabbit MQ集群</h3><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112201828727.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112201828727.png" alt="image-20240112201828727"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112201917704.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112201917704.png" alt="image-20240112201917704"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112201936906.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112201936906.png" alt="image-20240112201936906"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112202010343.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112202010343.png" alt="image-20240112202010343"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112202054291.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112202054291.png" alt="image-20240112202054291"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112202105935.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112202105935.png" alt="image-20240112202105935"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112202131376.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112202131376.png" alt="image-20240112202131376"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112202145328.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112202145328.png" alt="image-20240112202145328"></a></p>
<h3 id="10-2-镜像队列"><a href="#10-2-镜像队列" class="headerlink" title="10.2 镜像队列"></a>10.2 镜像队列</h3><p>在创建RabbitMQ集群时，如果1号MQ宕机，那么一号MQ的队列就会被备份到其他任一一台MQ上，比如备份到2号MQ上，计算2号MQ宕机了其还会备份至3号机上。</p>
<p>控制台Policy设置镜像队列：</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112203313443.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112203313443.png" alt="image-20240112203313443"></a></p>
<h3 id="10-3-Haproxy-keepalive实现高可用负载均衡"><a href="#10-3-Haproxy-keepalive实现高可用负载均衡" class="headerlink" title="10.3 Haproxy + keepalive实现高可用负载均衡"></a>10.3 Haproxy + keepalive实现高可用负载均衡</h3><h4 id="10-3-1-整体架构图"><a href="#10-3-1-整体架构图" class="headerlink" title="10.3.1 整体架构图"></a>10.3.1 整体架构图</h4><p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112203815011.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112203815011.png" alt="image-20240112203815011"></a></p>
<h4 id="10-3-2-Haproxy实现负载均衡"><a href="#10-3-2-Haproxy实现负载均衡" class="headerlink" title="10.3.2 Haproxy实现负载均衡"></a>10.3.2 Haproxy实现负载均衡</h4><p>HAProxy提供高可用性、负载均衡及基于TCPHTTP应用的代理，支持虚拟主机，它是免费、快速并<br>且可靠的一种解决方案，包括Twitter,Reddit,StackOverflow,GitHub在内的多家知名互联网公司在使用。<br>HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。</p>
<h3 id="10-4-Federation-Exchange（联邦交换机）"><a href="#10-4-Federation-Exchange（联邦交换机）" class="headerlink" title="10.4 Federation Exchange（联邦交换机）"></a>10.4 Federation Exchange（联邦交换机）</h3><h4 id="10-4-1-使用原因"><a href="#10-4-1-使用原因" class="headerlink" title="10.4.1 使用原因"></a>10.4.1 使用原因</h4><p>(broker北京)，(broker深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京的业务(Client北京)需要连接(broker北京)，向其中的交换器exchangeA发送消息，此时的网络延迟很小，(Client:北京)可以迅速将消息发送至exchangeA中，就算在开启了publisherconfirm机制或者事务机制的情况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client深圳)需要向exchangeA发送消息，那么(Client深圳)(broker北京)之间有很大的网络延迟，(Client深圳)将发送消息至exchangeA会经历一定的延迟，尤其是在开启了publisherconfirm机制或者事务机制的情况下，(Client深圳)会等待很长的延迟时间来接(broker北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻塞。<br>将业务(Client深圳)部署到北京的机房可以解决这个问题，但是如果(Client深圳)调用的另些服务都部<br>署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么又该如何实现？<br>这里使用Federation插件就可以很好地解决这个问题，</p>
<h4 id="10-4-2-搭建步骤"><a href="#10-4-2-搭建步骤" class="headerlink" title="10.4.2 搭建步骤"></a>10.4.2 搭建步骤</h4><p>1.需要保证每台节点单独运行<br>2.在每台机器上开启federation相关插件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">rabbitmq-plugins enable rabbitmq_federation</span><br><span class="line">rabbitmq-plugins enable rabbitmq_federation_management</span><br></pre></td></tr></tbody></table></figure>

<p>3.原理图（先运行consumer在node2创建fed_exchange)</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112204935113.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112204935113.png" alt="image-20240112204935113"></a></p>
<h3 id="10-5-Shovel（数据迁移）"><a href="#10-5-Shovel（数据迁移）" class="headerlink" title="10.5 Shovel（数据迁移）"></a>10.5 Shovel（数据迁移）</h3><h4 id="10-5-1-使用原因"><a href="#10-5-1-使用原因" class="headerlink" title="10.5.1 使用原因"></a>10.5.1 使用原因</h4><p>Federation具备的数据转发功能类似，Shovel够可靠、持续地从一个Broker中的队列（作为源端，即<br>source)拉取数据并转发至另一个Broker中的交换器（作为目的端，即destination)。作为源端的队列和作<br>为目的端的交换器可以同时位于同一个Broker,也可以位于不同的Broker上。Shovel可以翻译为”铲子”，<br>是一种比较形象的比喻，这个”铲子”可以将消息从一方”铲子”另一方。Shovel行为就像优秀的客户端应用<br>程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p>
<h4 id="10-6-2-搭建步骤"><a href="#10-6-2-搭建步骤" class="headerlink" title="10.6.2 搭建步骤"></a>10.6.2 搭建步骤</h4><ol>
<li>开启插件</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">rabbitmq-plugins enable rabbitmq_shovel</span><br><span class="line">rabbitmq-plugins enable rabbitmq_shovel_management</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>原理图（在源头发送的消息直接进入到目的队列）</p>
<p><a target="_blank" rel="noopener" href="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112205613195.png"><img src="https://blog.hejiajun.icu/2024/03/03/RabbitMQb%E7%AC%94%E8%AE%B0/study/IDEA/java%E6%96%87%E4%BB%B6/blog/source_posts/RabbitMQb%E7%AC%94%E8%AE%B0/image-20240112205613195.png" alt="image-20240112205613195"></a></p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雪荷</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/02/RabbitMQ%E7%AC%94%E8%AE%B0/">http://example.com/2024/07/02/RabbitMQ%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">雪荷的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></div><div class="post_share"><div class="social-share" data-image="/img/post_1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/02/RabbitMQ%E4%B8%80%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%BA%94%E7%94%A8/" title="RabbitMQ——死信队列介绍和使用"><img class="cover" src="/img/post_1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ——死信队列介绍和使用</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/02/Redis%20%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Redis 面试题"><img class="cover" src="/img/post_2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis 面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/07/RabbitMQ-%E5%85%AB%E8%82%A1%E6%96%87/" title="RabbitMQ 八股文"><img class="cover" src="/img/post_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">RabbitMQ 八股文</div></div></a></div><div><a href="/2024/07/02/RabbitMQ%E4%B8%80%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%BA%94%E7%94%A8/" title="RabbitMQ——死信队列介绍和使用"><img class="cover" src="/img/post_1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-02</div><div class="title">RabbitMQ——死信队列介绍和使用</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/ava.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">雪荷</div><div class="author-info__description">热爱生活，热爱编程</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-MQ%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 MQ相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E4%BB%80%E4%B9%88%E6%98%AFMQ"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 什么是MQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8MQ"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 为什么要用MQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-MQ%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3 MQ的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Rabbit-MQ"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 Rabbit MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-Rabbit-MQ%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 Rabbit MQ的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 四大核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-Rabbit-MQ%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 Rabbit MQ核心部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E5%90%84%E4%B8%AA%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.2.4 各个名词介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-hello-world%E2%80%94%E2%80%94RabbitMQ%E5%88%9D%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">2. hello world——RabbitMQ初使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%88%9B%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2 创建生产者和消费者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Work-Queues%EF%BC%88%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">3. Work Queues（工作队列）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BD%AE%E8%AF%A2%E5%88%86%E5%8F%91%E6%B6%88%E6%81%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 轮询分发消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 消息应答</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">3.2.1概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">3.2.2 自动应答</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3.2.3 消息应答的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-Multiple%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">3.2.4 Multiple的解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E6%B6%88%E6%81%AF%E8%87%AA%E5%8A%A8%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">3.2.5 消息自动重新入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-MQ%E5%BC%80%E5%90%AF%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">3.2.6 MQ开启手动应答</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-7-%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94%E5%AE%9E%E6%88%98"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">3.6.7 手动应答实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-RabbitMQ%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3 RabbitMQ持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">3.3.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">3.3.2 队列如何实现持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3.3.3 消息实现持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-%E4%B8%8D%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91%EF%BC%88%E8%83%BD%E8%80%85%E5%A4%9A%E5%8A%B3%EF%BC%89"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">3.3.4 不公平分发（能者多劳）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5%E9%A2%84%E5%8F%96%E5%80%BC"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">3.3.5预取值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4"><span class="toc-number">1.5.</span> <span class="toc-text">4. 发布确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 发布确认原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 发布确认的策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%8D%95%E4%B8%AA%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">4.2.1 单个确认发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E6%89%B9%E9%87%8F%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">4.2.2 批量确认发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E5%BC%82%E6%AD%A5%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">4.2.3 异步确认发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E4%B8%89%E7%A7%8D%E5%8F%91%E5%B8%83%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">4.2.4 三种发布的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E5%AE%9E%E6%88%98"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">4.2.5 发布确认实战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.6.</span> <span class="toc-text">5. 交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Exchange"><span class="toc-number">1.6.1.</span> <span class="toc-text">5.1 Exchange</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-Exchange%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">5.1.1 Exchange的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E6%97%A0%E5%90%8DExchange"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">5.1.2 无名Exchange</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%B8%B4%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number">1.6.2.</span> <span class="toc-text">5.2 临时队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%BB%91%E5%AE%9A%E9%98%9F%E5%88%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">5.3 绑定队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-Fanout%EF%BC%88%E6%89%87%E5%87%BA%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">5.3.1 Fanout（扇出模式）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-Fanout%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%AE%9E%E6%88%98"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">5.3.2 Fanout交换机实战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-Direct-exchange"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">5.3.3 Direct exchange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-Direct%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%AE%9E%E6%88%98"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">5.3.4 Direct交换机实战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-5-%E5%A4%9A%E9%87%8D%E7%BB%91%E5%AE%9A"><span class="toc-number">1.6.3.5.</span> <span class="toc-text">5.3.5 多重绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Topic%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.6.4.</span> <span class="toc-text">5.4 Topic交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E5%89%8D%E5%87%A0%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9A"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">5.4.1 前几种交换机模式的缺陷：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-Topic%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%AF%B9routingKey%E7%9A%84%E4%B9%A6%E5%86%99%E8%A6%81%E6%B1%82"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">5.4.2 Topic交换机对routingKey的书写要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-Topic%E5%8C%B9%E9%85%8D%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">5.4.3 Topic匹配案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-4-Topic%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%AE%9E%E6%88%98%EF%BC%9A"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">5.4.4 Topic交换机实战：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.7.</span> <span class="toc-text">6. 死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">6.1 死信的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BA%A7%E7%94%9F%E6%AD%BB%E4%BF%A1%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.7.2.</span> <span class="toc-text">6.2 产生死信的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%AD%BB%E4%BF%A1%E5%AE%9E%E6%88%98"><span class="toc-number">1.7.3.</span> <span class="toc-text">6.3 死信实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">6.3.1 代码架构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E6%B6%88%E6%81%AFTTL%E8%BF%87%E6%9C%9F"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">6.3.2 消息TTL过期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E9%98%9F%E5%88%97%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">6.3.3 队列达到最大长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-4-%E6%B6%88%E6%81%AF%E8%A2%AB%E6%8B%92"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">6.3.4 消息被拒</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%88%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">7. 延迟队列（死信队列实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">7.1 延迟队列的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.8.2.</span> <span class="toc-text">7.2 延迟队列的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%95%B4%E5%90%88Spring-Boot%EF%BC%89"><span class="toc-number">1.8.3.</span> <span class="toc-text">7.3 延迟队列的代码实现（整合Spring Boot）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.4.</span> <span class="toc-text">7.4 延迟队列的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.5.</span> <span class="toc-text">7.5 延迟队列插件实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.8.6.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%AB%98%E7%BA%A7"><span class="toc-number">1.9.</span> <span class="toc-text">8. 发布确认高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4Spring-Boot%E7%89%88%E6%9C%AC"><span class="toc-number">1.9.1.</span> <span class="toc-text">8.1 发布确认Spring Boot版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%E6%96%B9%E6%A1%88"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">8.1.1 确认机制方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">8.1.2 代码结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE%E7%B1%BB%EF%BC%88%E6%B3%A8%E6%84%8F%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%A0%E4%B8%8A-Configuration%E6%B3%A8%E8%A7%A3%EF%BC%89"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">8.1.3 编写配置类（注意一定要加上@Configuration注解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-4-%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">8.1.4 回调接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%9B%9E%E9%80%80%E6%B6%88%E6%81%AF"><span class="toc-number">1.9.2.</span> <span class="toc-text">8.2 回退消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-Mandatory%E5%8F%82%E6%95%B0"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">8.1.1 Mandatory参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9B%9E%E9%80%80%E6%B6%88%E6%81%AF%EF%BC%9F-%E5%AE%9E%E7%8E%B0RabbitTemplate-ReturnsCallback%E6%8E%A5%E5%8F%A3%E7%9A%84returnedMessage%E5%9B%9E%E9%80%80%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.2.1.1.</span> <span class="toc-text">如何回退消息？ =&gt; 实现RabbitTemplate.ReturnsCallback接口的returnedMessage回退方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%A4%87%E4%BB%BD%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.9.3.</span> <span class="toc-text">8.3 备份交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">8.3.1 代码架构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">8.3.2 修改配置类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.4.</span> <span class="toc-text">8.3.3 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-RabbitMQ%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.10.</span> <span class="toc-text">9. RabbitMQ其他知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">1.10.1.</span> <span class="toc-text">9.1 幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">9.1.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">9.1.2 消息重复消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF1%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%89"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">9.1.3 解决思路1（乐观锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF2-%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="toc-number">1.10.1.4.</span> <span class="toc-text">9.1.4 解决思路2 消费端的幂等性保障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-5-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF3-%E5%94%AF%E4%B8%80ID-%E6%8C%87%E7%BA%B9%E7%A0%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.1.5.</span> <span class="toc-text">9.1.5 解决思路3 唯一ID+指纹码机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-6-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF4-Redis%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">1.10.1.6.</span> <span class="toc-text">9.1.6 解决思路4 Redis原子性（推荐）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">1.10.2.</span> <span class="toc-text">9.2 优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">9.2.1 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">9.2.2 如何添加优先级队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-number">1.10.3.</span> <span class="toc-text">9.3 惰性队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.10.4.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">9.3.1 两种模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-%E5%86%85%E5%AD%98%E5%BC%80%E9%94%80%E5%AF%B9%E6%AF%94"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">9.3.2 内存开销对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-RabbitMQ%E9%9B%86%E7%BE%A4"><span class="toc-number">1.11.</span> <span class="toc-text">10. RabbitMQ集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E6%90%AD%E5%BB%BARabbit-MQ%E9%9B%86%E7%BE%A4"><span class="toc-number">1.11.1.</span> <span class="toc-text">10.1 搭建Rabbit MQ集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97"><span class="toc-number">1.11.2.</span> <span class="toc-text">10.2 镜像队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-Haproxy-keepalive%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.11.3.</span> <span class="toc-text">10.3 Haproxy + keepalive实现高可用负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">10.3.1 整体架构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-Haproxy%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">10.3.2 Haproxy实现负载均衡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-Federation-Exchange%EF%BC%88%E8%81%94%E9%82%A6%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%89"><span class="toc-number">1.11.4.</span> <span class="toc-text">10.4 Federation Exchange（联邦交换机）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">10.4.1 使用原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">10.4.2 搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-Shovel%EF%BC%88%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%EF%BC%89"><span class="toc-number">1.11.5.</span> <span class="toc-text">10.5 Shovel（数据迁移）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-1-%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">10.5.1 使用原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-2-%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">10.6.2 搭建步骤</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/JVM-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM 面试题"><img src="/img/post_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM 面试题"></a><div class="content"><a class="title" href="/2024/09/22/JVM-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM 面试题">JVM 面试题</a><time datetime="2024-09-22T14:42:32.000Z" title="发表于 2024-09-22 22:42:32">2024-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/21/JUC-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JUC 面试题"><img src="/img/post_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC 面试题"></a><div class="content"><a class="title" href="/2024/09/21/JUC-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JUC 面试题">JUC 面试题</a><time datetime="2024-09-21T14:02:31.000Z" title="发表于 2024-09-21 22:02:31">2024-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/06/%E9%9D%A2%E8%AF%95%E7%8B%97-interviewdog-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="面试狗 - interviewdog 项目笔记"><img src="/img/post_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试狗 - interviewdog 项目笔记"></a><div class="content"><a class="title" href="/2024/09/06/%E9%9D%A2%E8%AF%95%E7%8B%97-interviewdog-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="面试狗 - interviewdog 项目笔记">面试狗 - interviewdog 项目笔记</a><time datetime="2024-09-06T15:49:00.000Z" title="发表于 2024-09-06 23:49:00">2024-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/12/Redisson-%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/" title="Redisson 详细使用"><img src="/img/post_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redisson 详细使用"></a><div class="content"><a class="title" href="/2024/08/12/Redisson-%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/" title="Redisson 详细使用">Redisson 详细使用</a><time datetime="2024-08-12T15:06:31.000Z" title="发表于 2024-08-12 23:06:31">2024-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/29/%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%87%BA-Excel-%E7%9A%84%EF%BC%9F/" title="手摸手教你前端和后端是如何实现导出 Excel 的？"><img src="/img/post_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手摸手教你前端和后端是如何实现导出 Excel 的？"></a><div class="content"><a class="title" href="/2024/07/29/%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%87%BA-Excel-%E7%9A%84%EF%BC%9F/" title="手摸手教你前端和后端是如何实现导出 Excel 的？">手摸手教你前端和后端是如何实现导出 Excel 的？</a><time datetime="2024-07-29T14:59:29.000Z" title="发表于 2024-07-29 22:59:29">2024-07-29</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By 雪荷</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'uTxTLDSTgec4bcmjQMhzZLXJ-gzGzoHsz',
      appKey: 'Mj7im3r78jFLJCaSKJKqGj7m',
      avatar: 'monsterid',
      serverURLs: 'https://utxtldst.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, ))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>