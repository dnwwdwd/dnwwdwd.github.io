<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BI 项目笔记 | 雪荷的博客</title><meta name="author" content="雪荷"><meta name="copyright" content="雪荷"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="智能BI笔记使用后端万用模板时的注意事项 更改pom文件的项目名name，包名com.hjj、工件名lingxibi和Spring Boot版本（包名要全局更改） 检查和更改项目的JDK版本 更改swagger接口文档的包扫描范围 更改yml文件的端口，项目名spring.application.name和数据库的信息，如url、username、password 更改Spring Boot启动类">
<meta property="og:type" content="article">
<meta property="og:title" content="BI 项目笔记">
<meta property="og:url" content="http://example.com/2024/07/07/BI-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="雪荷的博客">
<meta property="og:description" content="智能BI笔记使用后端万用模板时的注意事项 更改pom文件的项目名name，包名com.hjj、工件名lingxibi和Spring Boot版本（包名要全局更改） 检查和更改项目的JDK版本 更改swagger接口文档的包扫描范围 更改yml文件的端口，项目名spring.application.name和数据库的信息，如url、username、password 更改Spring Boot启动类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/post_2.png">
<meta property="article:published_time" content="2024-07-07T03:02:32.000Z">
<meta property="article:modified_time" content="2024-07-08T14:06:07.873Z">
<meta property="article:author" content="雪荷">
<meta property="article:tag" content="项目笔记">
<meta property="article:tag" content="灵犀 BI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/post_2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/07/BI-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BI 项目笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-08 22:06:07'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/ava.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/post_2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="雪荷的博客"><span class="site-name">雪荷的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BI 项目笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-07T03:02:32.000Z" title="发表于 2024-07-07 11:02:32">2024-07-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-08T14:06:07.873Z" title="更新于 2024-07-08 22:06:07">2024-07-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BI 项目笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('/img/post_2.png');"></div><article class="post-content" id="article-container"><h1 id="智能BI笔记"><a href="#智能BI笔记" class="headerlink" title="智能BI笔记"></a>智能BI笔记</h1><h2 id="使用后端万用模板时的注意事项"><a href="#使用后端万用模板时的注意事项" class="headerlink" title="使用后端万用模板时的注意事项"></a>使用后端万用模板时的注意事项</h2><ol>
<li>更改pom文件的项目名name，包名<groupid>com.hjj</groupid>、工件名<artifactid>lingxibi</artifactid>和Spring Boot版本（包名要全局更改）</li>
<li>检查和更改项目的JDK版本</li>
<li>更改swagger接口文档的包扫描范围</li>
<li>更改yml文件的端口，项目名spring.application.name和数据库的信息，如url、username、password</li>
<li>更改Spring Boot启动类@MapperScan的包扫描路径</li>
<li>修改banner.txt文件</li>
</ol>
<h2 id="项目后端初始化注意事项"><a href="#项目后端初始化注意事项" class="headerlink" title="项目后端初始化注意事项"></a>项目后端初始化注意事项</h2><ol>
<li>使用MyBatisX插件生成代码时，将生成的代码转移到对应的包中（原来包中已存在UserService、User等类根据需求去取舍user表中的字段和User类的变量）</li>
<li>将自增ID改为IdType.AUTO</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@TableId(value = "id", type = IdType.AUTO)</span><br><span class="line">    private Long id;</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>后端启动项目端口冲突问题原因：Windows Hyper-V虚拟化平台占用了端口先使用：netsh interface ipv4 show excludedportrange protocol:=tcp查看被占用的端口，然后选择一个没被占用的端口启动项目禁用hyper -v</li>
</ol>
<h3 id="后端出现的问题"><a href="#后端出现的问题" class="headerlink" title="后端出现的问题"></a>后端出现的问题</h3><ol>
<li>单元测试显示AIManager空指针异常，在Test测试类上加上@SpringBootTest注解，保证能够扫描到全部的包，使得能够加载SpringBoot中的Bean</li>
<li>因为运算符短路原则而出现的问题queryWrapper.eq(id &gt; 0 &amp;&amp; id != null, “id”, id);会报错，而queryWrapper.eq( id != null &amp;&amp; id &gt; 0, “id”, id);并不会报错</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在你的代码中，有一段条件判断语句：</span><br><span class="line"></span><br><span class="line">queryWrapper.eq(id &gt; 0 &amp;&amp; id != null, "id", id);</span><br><span class="line">这行代码的逻辑是：如果id &gt; 0并且id不为null，则使用queryWrapper.eq()方法添加查询条件。由于Java的逻辑运算符是短路的，即在第一个条件为false时不再执行后续的条件判断，因此在这里，id &gt; 0为false时，不会执行id != null的判断。</span><br><span class="line"></span><br><span class="line">因此，当id为null时，id &gt; 0为false，但由于短路，后续的id != null并不会被执行，所以条件判断结果为true。</span><br><span class="line"></span><br><span class="line">如果你想要根据id是否为null来进行条件判断，可以简化成：</span><br><span class="line"></span><br><span class="line">queryWrapper.eq(id != null, "id", id);</span><br><span class="line">这样就会根据id是否为null来决定是否添加查询条件。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="AI调教和使用"><a href="#AI调教和使用" class="headerlink" title="AI调教和使用"></a>AI调教和使用</h2><p>AI接口普遍都有输入字数限制，尽可能压缩数据，能够允许多传一些数据</p>
<p><strong>如何向 AI 提词（prompt）？</strong></p>
<h3 id="AI提词技巧1"><a href="#AI提词技巧1" class="headerlink" title="AI提词技巧1"></a>AI提词技巧1</h3><p><strong>持续输入，持续优化</strong></p>
<p><em>第一次问：</em></p>
<p>我给你三行数据，请你帮我分析网站的增长趋势，数据如下：</p>
<p>第一行：日期：1号，用户数：10人第二行：日期：2号，用户数：20人第三行：日期：3号，用户数：30人</p>
<h3 id="AI提词技巧2"><a href="#AI提词技巧2" class="headerlink" title="AI提词技巧2"></a>AI提词技巧2</h3><p><strong>数据压缩（内容压缩，比如把很长的内容提取关键词，也可以让AI来做）</strong></p>
<p>我给你三行数据，请你帮我分析网站的增长趋势。数据如下：</p>
<p>表头：日期，用户数1号，102号，203号，30</p>
<p>使用csv对excel文件的数据进行提取和压缩</p>
<p>easyexcel：<a target="_blank" rel="noopener" href="https://easyexcel.opensource.alibaba.com/docs/current/quickstart/read%EF%BC%88%E5%BC%80%E6%BA%90%EF%BC%89">https://easyexcel.opensource.alibaba.com/docs/current/quickstart/read（开源）</a></p>
<h3 id="如何调用AI"><a href="#如何调用AI" class="headerlink" title="如何调用AI"></a>如何调用AI</h3><p>输入：</p>
<p><strong>系统预设</strong>（提前告诉他职责、功能、回复格式要求） + 分析目标 + 压缩后的数据（<strong>预设很重要</strong>）</p>
<p>最简单的系统预设：假如你是一个数据分析师，接下来我会给你我的分析目标和原始数据，请告诉我分析结论。</p>
<h3 id="AI提问技巧"><a href="#AI提问技巧" class="headerlink" title="AI提问技巧"></a>AI提问技巧</h3><p>如果想要 AI 更好地理解我们的输入，给我们预期的、精确格式的输出，我们就需要严格控制咱们得提问词。</p>
<ol>
<li><strong>系统预设：</strong>你是一个数据分析刊师和前端开发专家，接下来我会按照以下固定格式给你提供内容：分析需求：{数据分析的需求和目标}原始数据:{csv格式的原始数据，用,作为分隔符}请根据以上内容，帮我生成数据分析结论和可视化图表代码分析需求：分析网站用户的增长情况原始数据：日期，用户数1号，102号，203号，30</li>
<li>控制输出格式（便于AI返回的内容能够更加方便地为我们所用）</li>
</ol>
<h3 id="3种调用AI的方式"><a href="#3种调用AI的方式" class="headerlink" title="3种调用AI的方式"></a>3种调用AI的方式</h3><ol>
<li>直接调用OpenAI 或者其他 AI 原始大模型官网的接口<a target="_blank" rel="noopener" href="https://platform.openai.com/docs/api-reference1)%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD%E6%8C%87%E5%AE%9AOPENAI">https://platform.openai.com/docs/api-reference1)在请求头中指定OPENAI</a> API KEYAuthorization:Bearer OPENAI API KEY2)找到你要使用的接口，比如Al对话接口：https:/platform.openai.com/docs/api-reference/,chat/create3)按照接口文档的示例，构造HTTP请求</li>
<li>使用云服务商提供的，封装后的AI接口Azure云优点：本地都能用缺点：依然要钱，可能更贵</li>
<li>利用鱼聪明 AI 提供的开放SDK</li>
</ol>
<h2 id="怎么生成图表"><a href="#怎么生成图表" class="headerlink" title="怎么生成图表"></a>怎么生成图表</h2><p>AI无法生成现成的图表，但是AI可以生成代码 ==&gt; 可以把代码利用前端组件库（Echarts）在网页进行展示</p>
<p>你是一个数据分析刊师和前端开发专家，接下来我会按照以下固定格式给你提供内容：分析需求：{数据分析的需求和目标}原始数据:{csv格式的原始数据，用,作为分隔符}请根据这两部分内容，按照以下格式生成内容（此外不要输出任何多余的开头、结尾、注释）</p>
<p>【【【【【【{前端Echarts V5 的 option 配置对象js代码，合理地将数据进行可视化}【【【【【【{ 明确的数据分析结论、越详细越好，不要生成多余的注释 }</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>如果用户上传一个超大的文件怎么办？比如100G？</p>
<p>只要涉及到用户自主上传的操作，一定要校验文件（图像）</p>
<ul>
<li>文件大小</li>
<li>文件后缀（但可以将含有非法内容改后缀名）</li>
<li>文件的内容（成本较高）</li>
<li>文件的合规性（比如敏感内容，建议用第三方的审核功能）</li>
</ul>
<p>扩展点：接入腾讯云的图片万象数据审核（COS 对象存储的审核功能）</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>现状：我们把每个图表的原始数据全部存放在了同一个数据表（Chart表）的字段里</p>
<p><strong>问题：</strong></p>
<ol>
<li>如果用户上传的原始数量很大、图表数日益增多，查询Chart表就会很慢</li>
<li>对于BI平台，用户是可以查看原始数据的、对原始数据进行简单查询的需求。现在如果把所有数据存放在一个字段（列）中，查询时，只能取出这个列的所有内容</li>
</ol>
<p><strong>解决方案：</strong> ==&gt; 分库分表</p>
<p>把每个图表的原始数据（chartData）单独保存为一个新的数据表，而不是都存在一个字段里，这样：</p>
<ol>
<li>存储时，能够分开存储，互不影响，也能增加安全性，（如果把每个用户上传的图表按列作为字段都存在同一个数据库表中，而不是每个图表生成一个对应的数据库表的话，会出现性能问题。因为如果有甲、乙两个人都在查数据，但是甲查得早而且查得数据量特别大，乙查的迟但查得数据量少，这就会导致乙查询时少数据量时反而耗时很长，影响其他用户查询）</li>
<li>查询时，可以使用多中SQL灵活取出需要的字段，查询性能更快</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>分开存储：</p>
<ol>
<li>存储图表信息时，不把数据存储为某个数据库表单个字段，而是新建一个chart_(图表d)的数据表通过图表id，数据列名，数据类型等字段，生成一下SQL语句，并执行即可</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--auto-generated definition--</span><br><span class="line">create table chart_1659210482555121666</span><br><span class="line">(</span><br><span class="line">    日期 int nul1,</span><br><span class="line">    用户数 int nul1</span><br><span class="line">)；</span><br></pre></td></tr></tbody></table></figure>

<p>分开查询：</p>
<ol>
<li>以前直接查询图表，取chartData字段；现在改为读取chart_{图表id}的数据表select * from chart_{图标id}</li>
</ol>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>水平分表、垂直分库</p>
<p>分表：数据量大时可以拆分，前1w用户1个表，后1w用户1个表。对于BI来说，每个图表信息（chartData）为一个表</p>
<p>分库：根据业务分库，比如用户是同一个库，订单支付信息相关的一个库，一般根据业务来</p>
<p>具体实现：MyBatis的动态SQL（根据代码灵活地生成SQL）</p>
<ol>
<li>想想我们分表建表时，哪些部分需要动态生成，比如数据库表名，字段名</li>
<li>在mapper.xml文件中定义SQL语句</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="queryChartData" parameterType="String" resultMap="hashmap"&gt;</span><br><span class="line">        select * from chart_#{cahrtId}</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="queryChartData" parameterType="string" resultMap="hashmap"&gt;</span><br><span class="line">        ${querySql}</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>缺点：有SQL注入风险</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ChartMapper extends BaseMapper&lt;Chart&gt; {</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; queryChartData(@Param("querySql") String querySql);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试用例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">public class ChartMapperTest {</span><br><span class="line">    @Resource</span><br><span class="line">    ChartMapper chartMapper;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void queryChartData() {</span><br><span class="line">        String chartId = "1750880023067357186";</span><br><span class="line">        String querySql = String.format("select * from chart_%s", chartId);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; resultData = chartMapper.queryChartData(querySql);</span><br><span class="line">        System.out.println(resultData);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>比如：select * from chart_12345 where id=1 or 1=1;</p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><h3 id="限流的几种算法"><a href="#限流的几种算法" class="headerlink" title="限流的几种算法"></a>限流的几种算法</h3><p>推荐文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6967742960540581918">https://juejin.cn/post/6967742960540581918</a></p>
<ol>
<li>固定窗口限流（食堂1小时只允许10个用户拿汉堡且1小时只能做10个，结果59分钟来了10个人，第1小时1分钟又来10个人，那么汉堡就不够）单位时间内允许部分操作1小时只允许10个用户操作<strong>优点：</strong>最简单<strong>缺点：</strong>可能出现流量突刺，流量高峰比如：前59分钟没有1个操作，第59分钟来了10操作；第1小时1分钟又来了10个操作。相当于2分钟内执行了20个操作，服务器仍然有高峰危险。</li>
<li>滑动窗口限流（每十分钟做一个汉堡，前一个小时汉堡被抢光了，1小时10分钟来了个新用户就能抢到1小时10分钟刚做的汉堡）单位时间内允许部分操作，但是这个单位时间是滑动的，需要指定一个滑动单位滑动单位1min：开始前：0s		1h		2h一分钟后：1min 1h1min 2h1min <strong>优点：</strong>能够解决上述流量突刺的问题，因为第59分钟时，限流窗口是59~1小时59分，这个时间段内只能接收10次请求，只要还在这个窗口内，更多的操作就会被拒绝<strong>缺点：</strong>实现较复杂，限流效果和你的滑动单位有关，滑动单位越小，限流效果越好，但往往很难选取一个特别合适的滑动单位。</li>
<li>漏桶限流（推荐）（大家排好队一个一个拿汉堡，前面拿完后面才能拿，大家拿汉堡的速率一样）以<strong>固定的速率</strong>处理请求（流水），当请求（水）桶满了后，拒绝请求（禁止灌水）。每秒处理10个请求，桶的容量为10，每0.1秒固定处理一次请求，如果1秒内来了10个请求，都可以处理完，但如果1秒内来了11个请求，最后那个请求就会溢出水桶，被拒绝。<strong>优点</strong>：能够一定程度上应对流量突刺；<strong>能够以固定速率处理请求，保证服务器的安全****缺点</strong>：没有办法迅速处理一批请求，只能一个一个按顺序来（固定速率的缺点）	<strong>使用场景：</strong>希望服务器以恒定速率处理请求</li>
<li>令牌桶限流（推荐）（快餐店提前做好10个汉堡，开抢时前十个人能够同时得到汉堡，不用排队，但是剩下的10个人只能等待下一批的10个汉堡做好才能拿）管理员先生成一批令牌，每秒生成10个令牌；当用户要操作前，先去拿一个令牌，有令牌的人就有资格同时执行操作，没有令牌就等着<strong>优点</strong>：能够并发处理同时的请求<strong>需要考虑的问题</strong>：还是存在时间单位的选取问题<strong>使用场景：</strong>服务器允许并发操作，希望性能高一些</li>
</ol>
<p>因为生成图表和结论是调用AI的，但调用AI是要成本的，那怎么防止用户疯狂刷量，防止破产呢？</p>
<p>解决问题：</p>
<ol>
<li>控制成本 ==&gt; 限制用户调用总次数</li>
<li>由于服务器同时刻处理的请求为10个，用户在短时间内疯狂使用（比如使用jmeter多次请求接口），导致服务器资源被占满，其他用户无法使用 ==&gt; 限流</li>
</ol>
<p>思考限流阈值多大合适？比如限制单个用户在每秒只能用几次？</p>
<h3 id="限流的实现"><a href="#限流的实现" class="headerlink" title="限流的实现"></a>限流的实现</h3><ol>
<li>本地限流（单机限流）每个服务器单独限流，一般适用于单体项目，即你的项目只有一个服务器</li>
</ol>
<ul>
<li><p>Guava RateLimiter实现令牌桶算法</p>
</li>
<li><p>令牌桶算法是一种常用的限流算法。它通过维护一个固定容量的令牌桶，每个请求需要获取一个令牌才能被处理。当令牌桶中的令牌不足时，新的请求将被限制。</p>
</li>
<li><p>Java 中可以使用Guava库的RateLimiter类实现令牌桶算法。例如：</p>
</li>
<li><p>计数器算法</p>
</li>
<li><p>计数器算法是一种简单的限流方法，通过计数器记录一定时间内的请求次数，当请求次数达到设定的阈值时，后续请求被拒绝。</p>
</li>
<li><p>可以使用 AtomicInteger 或 AtomicLong 进行计数，并结合定时任务或定时器来定时重置计数器。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"></span><br><span class="line">public class RateLimiterExample {</span><br><span class="line">    private static final RateLimiter rateLimiter = RateLimiter.create(10.0); // 每秒生成10个令牌</span><br><span class="line"></span><br><span class="line">    public void processRequest() {</span><br><span class="line">        if (rateLimiter.tryAcquire()) {</span><br><span class="line">            // 处理请求逻辑</span><br><span class="line">        } else {</span><br><span class="line">            // 请求被限流</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class CounterLimiter {</span><br><span class="line">    private static final int MAX_REQUESTS = 10;</span><br><span class="line">    private static final int RESET_INTERVAL = 60 * 1000; // 重置计数器的时间间隔，这里设置为1分钟</span><br><span class="line">    private static final AtomicInteger requestCounter = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public boolean allowRequest() {</span><br><span class="line">        int currentRequests = requestCounter.incrementAndGet();</span><br><span class="line">        if (currentRequests &gt; MAX_REQUESTS) {</span><br><span class="line">            return false; // 请求超过限制</span><br><span class="line">        }</span><br><span class="line">        // 处理请求逻辑</span><br><span class="line"></span><br><span class="line">        // 定时任务或定时器重置计数器</span><br><span class="line">        // resetCounter();</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void resetCounter() {</span><br><span class="line">        requestCounter.set(0);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>分布式限流（多机限流）如果你的项目部署在多个服务器上，那么需采用分布式限流</p>
</li>
<li><p>把用户的使用频率等数据放到一个集中的存储进行统计，比如Redis，这样无论用户的请求落到了哪台服务器，都以集中的数据存储内的数据为准（Redisson）</p>
</li>
<li><p>在网关集中进行限流和统计（比如Sentinel、Spring Cloud Gateway）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">public class DistributedRateLimiter {</span><br><span class="line">    private static final String REDIS_KEY = "request_counter";</span><br><span class="line">    private static final int MAX_REQUESTS = 100;</span><br><span class="line"></span><br><span class="line">    public boolean allowRequest() {</span><br><span class="line">        try (Jedis jedis = new Jedis("localhost")) {</span><br><span class="line">            Long currentRequests = jedis.incr(REDIS_KEY);</span><br><span class="line"></span><br><span class="line">            if (currentRequests &gt; MAX_REQUESTS) {</span><br><span class="line">                return false; // 请求超过限制</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // 处理请求逻辑</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Redisson-限流实现"><a href="#Redisson-限流实现" class="headerlink" title="Redisson 限流实现"></a>Redisson 限流实现</h4><p>Redisson内置了一个限流工具类，可以帮助你利用Redis来存储和统计。</p>
<p>RedisLimiterManager：什么是Manager？专门提供 RedisLimiterManager 限流基础服务的（<strong>提供了通用的能力</strong>）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = "spring.redis")</span><br><span class="line">@Data</span><br><span class="line">public class RedissonConfig {</span><br><span class="line"></span><br><span class="line">    private String host;</span><br><span class="line">    private String port;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient redissonClient(){</span><br><span class="line">        // 1. 创建配置</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        String redisAddress = String.format("redis://%s:%s", host, port);</span><br><span class="line">        config.useSingleServer().setAddress(redisAddress).setDatabase(3);//设置单个服务器，设置地址，选择数据库</span><br><span class="line">        // 2. 创建实例</span><br><span class="line">        RedissonClient redisson = Redisson.create(config);</span><br><span class="line">        return redisson;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">/**</span><br><span class="line"> * 专门提供 RedisLimiter 限流基础服务（提供了通用的能力）</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class RedisLimiterManager {</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流操作</span><br><span class="line">     *</span><br><span class="line">     * @param key 区分不同的限流器，比如不同的用户 id 应该分别统计</span><br><span class="line">     */</span><br><span class="line">    public void doRateLimit(String key) {</span><br><span class="line">        // 创建一个名称为user_limiter的限流器，每秒最多访问2次</span><br><span class="line">        RRateLimiter rateLimiter = redissonClient.getRateLimiter(key);</span><br><span class="line">        rateLimiter.trySetRate(RateType.OVERALL, 2, 1, RateIntervalUnit.SECONDS); // OVERALL类型：不管有多少台服务器都是放在一起统计的</span><br><span class="line">        // 每当一个操作来了后，请求一个令牌</span><br><span class="line">        boolean canOp = rateLimiter.tryAcquire(1);// 令牌请求数，处理请求需消耗的令牌</span><br><span class="line">        if (!canOp) {</span><br><span class="line">            throw new BusinessException(ErrorCode.TOO_MANY_REQUEST);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在需要限流的地方直接调用doRateLimit()方法就好了</p>
<h3 id="限流粒度"><a href="#限流粒度" class="headerlink" title="限流粒度"></a>限流粒度</h3><ol>
<li>针对某个方法限流，即最多允许同时XX个操作使用这个方法</li>
<li>针对某个用户限流，比如单个用户最多执行XX次操作</li>
<li>针对某个用户x方法限流，比如当个用户单位时间内最多执行x次这个方法</li>
</ol>
<p><strong>第五期计划</strong></p>
<ol>
<li>系统问题分析</li>
<li>异步化的思路</li>
<li>线程池的理论和实战</li>
<li>前端后端的异步化改造</li>
</ol>
<h2 id="系统问题分"><a href="#系统问题分" class="headerlink" title="系统问题分"></a>系统问题分</h2><p>问题场景：调用的服务处理能力有限，或者接口的处理（或返回）时长较长时，就应该考虑异步化了。</p>
<ol>
<li>用户等待时间有点儿长（因为要等AI生成）</li>
<li>业务服务器可能会有很多请求在处理，导致系统资源紧张，严重时导致服务器宕机或者无法处理新的请求</li>
<li>调用的第三方服务(A!能力)的处理能力是有限的，比如每3秒只能处理1个请求，会导致A!处理不过来，严重时A!可能会对咱们的后台系统拒绝</li>
</ol>
<h2 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a>异步化</h2><p>new Thread？</p>
<p>同步：一件事情做完，在做另一件事情。（烧水后处理工作）</p>
<p>异步：不用等一件事做完，就可以做另一件事情。等第一件事完成后，可以收到一个通知，通知你这件事做好了，你可以再进行后续的处理（烧水的时候，水壶有一个蜂鸣器；烧水时人可以同时处理工作。水烧好后，人能听到声音，就知道水烧好了)</p>
<h3 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h3><p>标准异步化的业务流程</p>
<ol>
<li>当用户要进行耗时很长的操作时，点击提交后，不需要在界面傻等，而是应该把这个任务保存到数据库中记录下来</li>
<li>用户要执行新任务时：a. 任务提交成功：</li>
</ol>
<ul>
<li>如果程序有多余的空闲线程，可以立刻去做这个任务</li>
<li>如果程序线程都在繁忙，无法继续处理，那就放在等待队列中</li>
</ul>
<ol>
<li>b. 任务提交失败：比如我们的程序所有线程都在忙，<strong>任务队列满了</strong></li>
</ol>
<ul>
<li>拒绝这个任务，再也不执行</li>
<li>通过保存到数据库中的记录来看到提交失败的任务，并且在程序空闲的时候，可以将任务从数据库中捞到程序里，再去执行</li>
</ul>
<ol>
<li>我们的程序（线程）从任务队列中取出任务依次执行，每完成一件事要修改一下任务的状态</li>
<li>用户可以查询任务的执行状态，或者在任务执行成功或者失败时能得到通知（发邮件、系统消息提示框、短信）</li>
<li>如果我们要执行的任务非常复杂，包含很多环节，在每一个小任务完成时，要在程序（数据库中）记录一下任务的执行状态（进度）</li>
</ol>
<h3 id="标准异步化的业务流程"><a href="#标准异步化的业务流程" class="headerlink" title="标准异步化的业务流程"></a>标准异步化的业务流程</h3><ol>
<li>用户点击智能分析页的提交按钮时，先把图表立刻保存到数据库中（作为一个任务）</li>
<li>用户可以在图表列表页面查看所有图表（已生成的、生成中、生成失败的）的信息和状态</li>
<li>用户可以修改生成失败的图表信息，点击重新生成</li>
</ol>
<p>问题：</p>
<ol>
<li>任务队列的最大容量应该设置为多少？</li>
<li>程序怎么从任务队列中取出任务并执行？这个任务队列的流程怎么实现？</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为什么需要线程池？</p>
<ol>
<li>线程的管理比较复杂（比如什么时候新增线程、什么时候减少空闲线程）</li>
<li>任务存取比较复杂（什么时候接受任务、什么时候拒绝任务，怎么保证大家不抢到同一个任务）</li>
</ol>
<p>线程池的作用：帮助你轻松管理线程，协调任务的执行过程</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h4><p>不用自己写，如果是在Spring中，可以用ThreadPoolTaskExecutor配合@Async注解来实现（不太建议）</p>
<p>如果是在Java中，可以使用JUC并发编程包的ThreadPoolExecutor来实现非常灵活的自定义线程池</p>
<p>线程池参数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) {</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>怎么确定线程池参数呢？结合业务场景和系统资源去测试调整，不断优化</p>
<p>回归到我们的业务，要考虑系统最脆弱的环节（系统的瓶颈）在哪里？现有条件：比如A!生成能力的并发是只允许4个任务同时去执行，AI能力允许20个任务排队。</p>
<p>回归到我们的业务，要考虑系统最脆弱的环节（系统的瓶颈）在哪里？现有条件：比如AI生成能力的并发是只允许4个任务同时去执行，AI能力允许20个任务排队。</p>
<p><strong>具体参数的介绍：</strong></p>
<p>corePoolSize(核心线程数=&gt;正式员工数)：正常情况下，我们的系统应该能同时工作的线程数（随时就绪的状态)maximumPoolSize(最大线程数=&gt;哪怕任务再多，你也最多招这些人)：极限情况下，我们的线程池最多有多少个线程？keepAliveTime(空闲线程存活时间)：非核心线程在没有任务的情况下，过多久要删除（理解为开除临时工），从而释放无用的线程资源。TimeUnit unit(空闲线程存活时间的单位)：分钟、秒workQueue(工作队列)：用于存放给线程执行的任务，存在一个队列的长度threadFactory(线程工厂)：控制每个线程的生成、线程的属性（比如线程名）RejectedExecutionHandler(拒绝策略)：任务队列满的时候，我们采取什么措施，比如抛异常、不抛异常、自定义策略</p>
<p>资源隔离策略：比如重要的任务（VIP）一个队列，普通的任务一个队列，保证这个两个队列互不干扰</p>
<p>线程池的工作机制</p>
<p><strong>本项目中如何设置线程池的参数</strong></p>
<p><strong>线程池的参数如何设置？</strong>现有条件：比如A!生成能力的并发是只允许4个任务同时去执行，AI能力允许20个任务排队。</p>
<p>corePoolSize(核心线程数=&gt;正式员工数)：正常情况下，可以设置为4maximumPoolSize:设置为极限情况，设置为&lt;=4keepAliveTime(空闲线程存活时间)：一般设置为秒级或者分钟级TimeUnit unit(空闲线程存活时间的单位)：分钟、秒workQueue(工作队列)：结合实际请况去设置，可以设置为20threadFactory(线程工厂)：控制每个线程的生成、线程的属性（比如线程名）RejectedExecutionHandler(拒绝策略)：抛异常，标记数据库的任务状态为”任务满了已拒绝”</p>
<p>一般情况下，任务分为<strong>IO密集型</strong>和<strong>计算密集型</strong>两种。<strong>计算密集型</strong>：吃CPU，比如音视频处理、图像处理、数学计算等，一般是设置corePoolSize为CPU的核数+1。maximumPoolSize一般设置为CPU核心数的2~3倍。(空余线程)，可以让每个线程都能利用好CPU的每个核，而且线程之间不用频繁切换（减少打架、减少开销）<strong>IO密集型</strong>：吃带宽内存/硬盘的读写资源，corePoolSize可以设置大一点，一般经验值是2n左右，但是建议以IO的能力为主。</p>
<p>导入百万数据到数据库是属于IO密集型还是CPU密集型？ ==&gt; IO密集型</p>
<h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ThreadPoolExecutorConfig {</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ThreadPoolExecutor threadPoolExecutor() {</span><br><span class="line">        ThreadFactory threadFactory = new ThreadFactory() {</span><br><span class="line">            private int count = 1;</span><br><span class="line">            @Override</span><br><span class="line">            public Thread newThread(@NotNull Runnable r) {</span><br><span class="line">                Thread thread = new Thread();</span><br><span class="line">                thread.setName("线程" + count);</span><br><span class="line">                return thread;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 4, 100,</span><br><span class="line">                TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(4), threadFactory);</span><br><span class="line">        return threadPoolExecutor;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="实现工作流程"><a href="#实现工作流程" class="headerlink" title="实现工作流程"></a>实现工作流程</h4><ol>
<li>给chart表新增任务状态字段（比如排队中、执行中、已完成、失败），任务执行信息字段（用于记录任务执行中、或者失败的一些信息)</li>
<li>用户点击智能分析页的提交按钮时，先把图表立刻保存到数据库中，然后提交任务</li>
<li>任务：先修改图表任务状态为“执行中”。等执行成功后，修改为“已完成”、保存执行结果；执行失败后，状态修改为“失败”，记录任务失败信息。</li>
<li>用户可以在图表管理页面查看所有图表（已生成的、生成中的、生成失败）的信息和状态用户可以修改生成失败的图表信息，点击重新生成</li>
</ol>
<h4 id="任务执行逻辑"><a href="#任务执行逻辑" class="headerlink" title="任务执行逻辑"></a>任务执行逻辑</h4><p>先修改任务状态为执行中，减少重复执行的风险、同时让用户知道执行状态</p>
<h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><ol>
<li>guava Retrying重试</li>
<li>提前考虑到AI生成错误的情况，在后端进行异常处理（比如AI说了多余的话，提取正确的字符串）</li>
<li>如果说任务根本没提交到队列中（或者队列已经满了），是不是可以用定时任务把失败状态的图表放在队列中（补偿）</li>
<li>给任务的执行增加一个超时时间，超时后自动标记为失败</li>
<li>反向压力：https:/zhuanlan.zhihu.com/p/404993753，通过调用的服务状态来选择当前系统的策略（比如根据AI服务的当前任务队列数来控制咱们系统的核心线程数)，<strong>从而最大化利用系统资源</strong>。</li>
<li>我的图表页面增加一个刷新，定时自动刷新的按钮，保证获取到图表的最新状态</li>
<li>任务执行成功或失败，给用户发送消息通知（实时：websocket、server side event）</li>
</ol>
<h2 id="第六期计划"><a href="#第六期计划" class="headerlink" title="第六期计划"></a>第六期计划</h2><ol>
<li>分析系统现在的不足</li>
<li>分布式消息队列</li>
<li>分布式消息队列RabbitMQ</li>
<li>项目扩展</li>
</ol>
<h2 id="分析系统化现状的不足"><a href="#分析系统化现状的不足" class="headerlink" title="分析系统化现状的不足"></a>分析系统化现状的不足</h2><p>单机系统的不足</p>
<p>已经经过了同步到异步化的改造</p>
<p>现状：目前的异步是通过本地的线程池实现的。</p>
<ol>
<li>无法集中限制，只能单机限制假如A!服务限制只能有2个用户同时使用，单个线程池可以限制最大核心线程数为2来实现。假设系统用量增大，改为分布式，多台服务器，每个服务器都要有2个线程，就有可能有2N个线程，超过了A!服务的限制。<strong>解决方案：</strong>在一个集中的地方去下发和管理任务（比如集中存储当前正在执行的任务数）</li>
<li>任务由于是放在内存中执行的，重启时可能会丢失虽然可以人工从数据库捞出来再重试，但是其实需要额外开发（比如定时任务），这种重试的场景是非常典型的，其实是不需要我们开发者过于关心、或者自己实现的。<strong>解决方案：</strong>把任务放在一个可以持久化存储的硬盘</li>
<li>优化：如果你的系统功能越来越多，长耗时任务越来越多，系统会越来越复杂（比如要开多个线程池、资源可能会出现项目抢占)。其实我们可以把长耗时、消耗很多的任务把它单独抽成一个程序，不要影响主业务。服务拆分（应用解耦）其实我们可以把长耗时、消耗很多的任务把它单独抽成一个程序，不要影响主业务。<strong>解决方案：</strong>可以有一个中间人，让中间人帮我们去连接两个系统（例如核心系统和智能生成业务）</li>
</ol>
<h2 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>连接多个系统、帮助多个系统紧密协作的技术、中间人</p>
<p>Redis、消息队列、分布式存储Etcd</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>存储消息的队列关键词：存储、消息、队列存储：存数据消息：某种数据结构，比如字符串、对象、二进制数据、jso等等队列：先进先出的数据结构</p>
<p>可以理解为消息队列是特殊的数据库</p>
<p>应用场景（作用）：在多个不同的系统、应用之间实现消息的传输。不需要考虑传输应用的编程语言、系统、框架等等。可以让jva开发的应用发消息，让php开发的应用收消息，这样就不用把所有代码写到同一个项目里（应用解耦)。</p>
<h3 id="消息队列的模型"><a href="#消息队列的模型" class="headerlink" title="消息队列的模型"></a>消息队列的模型</h3><p>生产者：Producer,,类比为快递员，发送消息的人（客户端）消费者：Consumer,类比为取快递的人，接受读取消息的人（客户端）消息：Message,类比为快递，就是生产者要传输给消费者的数据消息队列：Queue</p>
<p>为什么不直接传输，要用消息队列？生产者不用关心你的消费者要不要消费、什么时候消费，我只需要把东西给消息队列，我的工作就算完成了。</p>
<p>生产者和消费者实现了解耦，互不影响。</p>
<h3 id="为什么要用消息队列？"><a href="#为什么要用消息队列？" class="headerlink" title="为什么要用消息队列？"></a>为什么要用消息队列？</h3><ol>
<li>异步处理生产者发送完消息之后，可以继续忙别的，消费者什么时候消费都可以，不会产生阻塞</li>
<li>削峰填谷原本：1s内来了1w个请求，但服务器1s只能处理5k个氢气，那可以先把用户的请求放在消息队列中，消费者（实际执行操作的应用）可以按照自己的需求，慢慢去取现在：把1w的请求放在消息队列中，系统按照恒定的速率慢慢执行，从而保护系统的稳定性和安全性</li>
</ol>
<h3 id="分布式消息队列的优势"><a href="#分布式消息队列的优势" class="headerlink" title="分布式消息队列的优势"></a>分布式消息队列的优势</h3><ol>
<li>数据持久化：可以把消息存储到硬盘中，服务器重启也不会丢失</li>
<li>可扩展性：根据需求，随时增加（或减少）节点，搭建MQ集群</li>
<li>应用解耦：可以连接各个不同语言、框架开发的系统，让这些系统能够灵活传输读取数据</li>
</ol>
<h4 id="应用解耦的优点："><a href="#应用解耦的优点：" class="headerlink" title="应用解耦的优点："></a>应用解耦的优点：</h4><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中间用户感受不到物流系统的故障，提升系统的可用性。</p>
<h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><p>如果一个非常大的系统要给其他子系统发送通知，最简单直接的方式是大系统直接依次调用（通知）小系统：问题：</p>
<ol>
<li>每次发通知都要调用很多系统，很麻烦、有可能失败</li>
<li>新出现的项目（大项目感知不到的项目）无法得到通知</li>
</ol>
<p>解决方案：大的核心系统始终往一个地方（消息队列）发消息，其他的系统都去订阅这个消息队列（读取消息队列中的消息）</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>耗时的场景（异步）</li>
<li>高并发的场景（异步，削峰填谷）</li>
<li>分布式系统协作（尤其是跨团队，跨业务协作，应用解耦）</li>
<li>强稳定性的场景（比如金融业务，持久化、可靠性、削峰填谷）</li>
</ol>
<h3 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h3><p>也叫分布式场景下需要考虑的问题</p>
<ol>
<li>给系统引入额外的中间件，系统更复杂，额外维护中间件，额外的费用（部署、维护）成本</li>
<li>消息丢失、消息的顺序性、重复消费、数据的一致性（分布式系统就要考虑）</li>
</ol>
<h3 id="主流分布式消息队列选型"><a href="#主流分布式消息队列选型" class="headerlink" title="主流分布式消息队列选型"></a>主流分布式消息队列选型</h3><h4 id="主流技术"><a href="#主流技术" class="headerlink" title="主流技术"></a>主流技术</h4><ol>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>kafka</li>
<li>RocketMQ</li>
<li>zeroMQ</li>
<li>pulsar</li>
<li>Apache InLong（Tube）</li>
</ol>
<h4 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h4><p>技术选型指标：</p>
<ul>
<li>吞吐量：IO、并发</li>
<li>时效性：类似延迟，消息的发送，到达时间</li>
<li>可用性：系统可用的比率（比如1年365天宕机1s，可用率大概 X 个9）</li>
<li>可靠性：消息不会丢失（比如不丢失消息（订单）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>技术名称</strong></th>
<th><strong>吞吐量</strong></th>
<th><strong>时效性</strong></th>
<th><strong>可用性</strong></th>
<th><strong>可靠性</strong></th>
<th><strong>优势</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ActiveMQ</td>
<td>w级</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>简单易学</td>
<td>中小型企业、项目</td>
</tr>
<tr>
<td>RabbitMQ</td>
<td>w级</td>
<td>极高（us）</td>
<td>高</td>
<td>高</td>
<td>生态好（基本什么语言都支持、时效性高，易学）</td>
<td>适合绝大多数分布式的应用</td>
</tr>
<tr>
<td>kafka</td>
<td>10w级</td>
<td>高（ms以内）</td>
<td>极高</td>
<td>极高</td>
<td>吞吐量大、可靠性、可用性，强大的数据流处理能力</td>
<td>适用于大规模处理数据的场景，比如构建日志手机系统、实时数据流传输、事件流收集传输</td>
</tr>
<tr>
<td>RocketMQ</td>
<td>10w级</td>
<td>高（ms）</td>
<td>极高</td>
<td>极高</td>
<td>吞吐量大、可靠性、可用性，可扩展性</td>
<td>适用于金融、电商等对可靠性要求较高的场景，适合大规模的消息处理。</td>
</tr>
<tr>
<td>pulsar</td>
<td>10w级</td>
<td>高（ms）</td>
<td>极高</td>
<td>极高</td>
<td>可靠性、可用性很高，新型（技术架构先进），基于发布订阅模型</td>
<td>适合大规模、高并发的分布式系统（云原生)。适合实时分析、事件流处理、loT数据处理等。</td>
</tr>
</tbody></table>
<h3 id="RabbitMQ-入门实战"><a href="#RabbitMQ-入门实战" class="headerlink" title="RabbitMQ 入门实战"></a>RabbitMQ 入门实战</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>特点：生态好，好学习、易于理解，时效性强，支持很多不同语言的客户端，扩展性、可用性都很不错。学习性价比非常高的消息队列，适用于绝大多数中小规模分布式系统。</p>
<h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><p>AMQP协议：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">https://www.rabbitmq.com/tutorials/amqp-concepts.html</a></p>
<p>高级消息队列协议(Advanced Message Queue Protocol))</p>
<p>生产者：发消息到某个交换机消费者：从某个队列中取消息交换机(Exchange)：负责把消息转发到对应的队列队列(Queue):存储消息的路由(Routes)：转发，就是怎么把消息从一个地方转到另一个地方（比如从生产者转发到某个队列）Channel频道：理解为操作消息队列的client(比如jdbcClient、redisClient),提供了和消息队列server建立通信的传输方法（为了复用连接，提高传输效率）</p>
<h4 id="多消费者"><a href="#多消费者" class="headerlink" title="多消费者"></a>多消费者</h4><p>使用场景：多个消费者同时去接收并处理任务（尤其是每个消费者的处理能力有限）</p>
<p>一个生产者给一个队列发消息，多个消费者从这个队列取消息。1对多。</p>
<h4 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Channel.basicAck(long deliveryTag, boolean multiple)</span><br><span class="line"></span><br><span class="line">deliveryTag: 是消息的唯一标识符，通常由RabbitMQ在消息被投递时提供。</span><br><span class="line">multiple: 如果设置为true，则表示确认所有小于或等于deliveryTag的消息。这可以用于批量确认。</span><br><span class="line">basicAck方法用于确认一条或多条消息已经被成功处理。当消费者处理完一条消息并且准备告诉RabbitMQ可以安全地从队列中删除该消息时，它会调用这个方法。</span><br><span class="line"></span><br><span class="line">Channel.basicNack(long deliveryTag, boolean multiple, boolean requeue)</span><br><span class="line"></span><br><span class="line">deliveryTag: 同上，消息的唯一标识符。</span><br><span class="line">multiple: 同上，用于批量确认。</span><br><span class="line">requeue: 如果设置为true，则消息会被重新放回队列中，以便其他消费者可以处理它。如果设置为false，消息会被RabbitMQ删除或发送到死信队列（如果配置了的话）。</span><br><span class="line">basicNack方法用于告知RabbitMQ一条或多条消息处理失败。如果requeue参数设置为true，这些消息会被重新加入队列以供再次消费。</span><br><span class="line"></span><br><span class="line">Channel.basicReject(long deliveryTag, boolean requeue)</span><br><span class="line"></span><br><span class="line">deliveryTag: 消息的唯一标识符。</span><br><span class="line">requeue: 同上，决定消息是否被重新放回队列。</span><br><span class="line">basicReject方法用于拒绝单条消息。与basicNack不同，basicReject只适用于单条消息，而不是多条。如果消费者不能或不想处理某条消息，它可以调用这个方法。</span><br></pre></td></tr></tbody></table></figure>

<p>channel.basicQos(1);	// 限制消费者从队列中预取的消息数量；控制单个消费者的处理任务积压数，每个消费者最多同时处理1个任务</p>
<p><strong>2个小技巧：</strong>1.使用Scanner接受用户输入，便于快速发送多条消息2,使用for循环创建多个消费者，便于快速验证队列模型工作机制</p>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>场景：多个机器同时去接受并处理任务（尤其是每个机器的处理能力有限）一个生产者给多个队列发消息，1个生产者对多个队列。交换机的作用：提供消息转发功能，类似于网络路由器要解决的问题：怎么把消息转发到不同的队列上，使消费者从不同的队列消费</p>
<h4 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h4><p>绑定：可以让交换机和队列进行关联，可以指定让交互机把什么样的消息发送给哪个队列routingKey:路由键，控制消息要转发给哪个队列的</p>
<p>特点：消息会根据路由键转发到指定的队列场景：特定的消息只交给特定的系统（程序）来处理</p>
<p>比如发日志的场景，希望用独立的程序来处理不同级别的日志，比如C1系统处理eror日志，C2系统处理其他级别的日志</p>
<h4 id="topic交换机"><a href="#topic交换机" class="headerlink" title="topic交换机"></a>topic交换机</h4><p>特点：消息会根据一个模糊的路由键转发到指定的队列场景：特定的一类消息可以交给特定的一类系统（程序）来处理绑定关系：可以模糊匹配多个绑定</p>
<ul>
<li>*****:匹配一个单词，比如*.orange,那么a.orange、b.orange都能匹配</li>
<li>#:匹配0个或多个单词，比如a.#,那么a.a、a.b、a.a.a都能匹配</li>
</ul>
<p>应用场景：</p>
<p>老板要下发一个任务，让多个组来处理</p>
<p>注意，这里的匹配和MySQL的like的%不一样，只能按照单词来匹配，每个’，分隔单词，如果是’#.’，其实可以忽略，匹配0个词也Ok</p>
<h4 id="Headers-交换机"><a href="#Headers-交换机" class="headerlink" title="Headers 交换机"></a>Headers 交换机</h4><p>Headers Exchange 的路由规则不是基于路由键（routing key），而是基于消息的 header 属性进行匹配。</p>
<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>支持用消息队列来模拟 RPC 的调用，但是一般没必要，直接用 Dubbo、GRPC等RPC框架就好了</p>
<h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><h4 id="消息过期机制"><a href="#消息过期机制" class="headerlink" title="消息过期机制"></a>消息过期机制</h4><p>可以给每条消息制定一个有效期，一短时间内违背消费者处理，就过期了</p>
<p>示例场景：消费者（库存系统）挂了，一个订单15分钟还未被库存系统处理，这个订单就已经失效了，哪怕库存系统再恢复，其实也不同扣减库存</p>
<p>适用场景：清理过期数据、模拟延迟队列的实现</p>
<ol>
<li>给队列中的所有消息指定过期时间</li>
<li>给某条消息指定过期时间注意：如果消息已经发到消费者手上，但是未确认，消息是不会过期的。相反，如果消息未发送到消费者手上，并且消息达到过期时间，那么消息就会过期。</li>
</ol>
<h4 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h4><p>官方文档：https:/<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/dlx.html">www.rabbitmq.com/dlx.html</a>为了保证消息的可靠性，比如每条消息都成功消费，需要提供一个容措机制，即：失败的消息怎么处理？死信：过期的消息、拒收的消息、消息队列满了、处理失败的消息的统称死信队列：专门处理死信的队列（注意，它就是一个普通队列，只不过是专门用来处理死信的，你甚至可以理解这个队列的名称叫“死信队列”)死信交换机：专门给死信队列转发消息的交换机（注意，它就是一个普通交换机，只不过是专门给死信队列发消息而已，理解为这个交换机的名称就叫“死信交换机”)。也存在路由绑定死信可以通过死信交换机绑定到死信队列。</p>
<p>示例场景：</p>
<h3 id="RabbitMQ重点知识"><a href="#RabbitMQ重点知识" class="headerlink" title="RabbitMQ重点知识"></a>RabbitMQ重点知识</h3><p>也是面试重点</p>
<ol>
<li>消息队列的概念、模型、应用场景</li>
<li>交换机的类别、路由绑定的关系</li>
<li>消息可靠性a. 消息确认机制(ack、nack、reject)b. 消息持久化(durable)c. 消息过期机制d. 死信队列</li>
<li>延迟队列（类似死信队列）</li>
<li>顺序消费、消费幂等性（本次不讲）</li>
<li>可扩展性（仅作了解）a. 集群b. 故障的恢复机制c. 镜像</li>
<li>运维监控告警（仅作了解）</li>
</ol>
<h3 id="RabbitMQ-项目实战"><a href="#RabbitMQ-项目实战" class="headerlink" title="RabbitMQ 项目实战"></a>RabbitMQ 项目实战</h3><p>怎么在项目中使用RabbitMQ？</p>
<ol>
<li>使用官方的客户端（优点：兼容性好，换语言成本低，比较灵活；缺点：太灵活，要自己处理某些事情）</li>
<li>使用封装好的客户端、比如Spring Boot RabbitMQ Starter优点：简单医用，直接配置直接用缺点：封装的太好了，没学过的话就不知道怎么用。不够灵活，被框架限制死了</li>
</ol>
<p>根据场景来选择，没有绝对的优劣（类似JDBC和MyBatis）</p>
<p>有技术和英文水平的话，建议看官方文档，不要看过期博客</p>
<p>注意试用版本要和Spring Boot版本一致</p>
<p>生产者代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyMessageProducer {</span><br><span class="line">    @Resource</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(String exchange, String routineKey, String message) {</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routineKey, message);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>消费者队列</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyMessageConsumer {</span><br><span class="line">    @Resource</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    @RabbitListener(queues = {"code_queue"}, ackMode = "MANUAL")</span><br><span class="line">    public void receiveMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) {</span><br><span class="line">        channel.basicAck(deliveryTag, false);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>单元测试</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class MyMessageProducerTest {</span><br><span class="line">    @Resource</span><br><span class="line">    private MyMessageProducer myMessageProducer;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void sendMessage() {</span><br><span class="line">        myMessageProducer.sendMessage("code_exchange", "my_routineKey", "你好呀");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="BI项目通过RabbitMQ改造"><a href="#BI项目通过RabbitMQ改造" class="headerlink" title="BI项目通过RabbitMQ改造"></a>BI项目通过RabbitMQ改造</h3><p>以前是把任务提交到线程池，然后在线程池提交中编写处理程序的代码，线程池内排队。如果程序中断了，任务就没了，就丢了。</p>
<p>改造后的流程：</p>
<ol>
<li>把任务提交改为向队列发送消息</li>
<li>写一个专门接收消息的队列，处理任务</li>
<li>如果程序中断了，消息未被确认，还会重发么？</li>
<li>现在，消息全部集中发送到消息队列，可以部署多个后端，都从一个地发取任务，实现分布式负载均衡</li>
</ol>
<p>验证发现，如果程序中中断了，没有ack也没有nack（服务中断，没有任何响应），那么这条消息会重新入队，从而实现了每个任务都会执行。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">雪荷</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/07/BI-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/">http://example.com/2024/07/07/BI-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">雪荷的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/">项目笔记</a><a class="post-meta__tags" href="/tags/%E7%81%B5%E7%8A%80-BI/">灵犀 BI</a></div><div class="post_share"><div class="social-share" data-image="/img/post_2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/07/%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2%E7%81%B5%E7%8A%80-BI/" title="宝塔部署灵犀 BI"><img class="cover" src="/img/post_2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">宝塔部署灵犀 BI</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/07/API-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="API 项目笔记"><img class="cover" src="/img/post_2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">API 项目笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/07/%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2%E7%81%B5%E7%8A%80-BI/" title="宝塔部署灵犀 BI"><img class="cover" src="/img/post_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">宝塔部署灵犀 BI</div></div></a></div><div><a href="/2024/07/07/API-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="API 项目笔记"><img class="cover" src="/img/post_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">API 项目笔记</div></div></a></div><div><a href="/2024/07/02/OJ%20%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="OJ 项目笔记"><img class="cover" src="/img/post_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-02</div><div class="title">OJ 项目笔记</div></div></a></div><div><a href="/2024/07/02/homie%20%E5%8C%B9%E9%85%8D%20websocket%20%E8%81%8A%E5%A4%A9%E9%83%A8%E5%88%86/" title="homie 匹配 websocket 聊天部分"><img class="cover" src="/img/post_1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-02</div><div class="title">homie 匹配 websocket 聊天部分</div></div></a></div><div><a href="/2024/07/07/homie-%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="homie 匹配项目笔记"><img class="cover" src="/img/post_1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">homie 匹配项目笔记</div></div></a></div><div><a href="/2024/07/07/homie-%E5%8C%B9%E9%85%8D%E5%BC%95%E5%85%A5-GEO-%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E9%99%84%E8%BF%91%E7%94%A8%E6%88%B7/" title="homie 匹配引入 GEO 实现搜索附近用户"><img class="cover" src="/img/post_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">homie 匹配引入 GEO 实现搜索附近用户</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/ava.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">雪荷</div><div class="author-info__description">热爱生活，热爱编程</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BDBI%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">智能BI笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%8E%E7%AB%AF%E4%B8%87%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.1.</span> <span class="toc-text">使用后端万用模板时的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.</span> <span class="toc-text">项目后端初始化注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">后端出现的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AI%E8%B0%83%E6%95%99%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">AI调教和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AI%E6%8F%90%E8%AF%8D%E6%8A%80%E5%B7%A71"><span class="toc-number">1.3.1.</span> <span class="toc-text">AI提词技巧1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AI%E6%8F%90%E8%AF%8D%E6%8A%80%E5%B7%A72"><span class="toc-number">1.3.2.</span> <span class="toc-text">AI提词技巧2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8AI"><span class="toc-number">1.3.3.</span> <span class="toc-text">如何调用AI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AI%E6%8F%90%E9%97%AE%E6%8A%80%E5%B7%A7"><span class="toc-number">1.3.4.</span> <span class="toc-text">AI提问技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%A7%8D%E8%B0%83%E7%94%A8AI%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.5.</span> <span class="toc-text">3种调用AI的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">怎么生成图表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.5.</span> <span class="toc-text">安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.</span> <span class="toc-text">数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">分库分表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E6%B5%81"><span class="toc-number">1.7.</span> <span class="toc-text">限流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.1.</span> <span class="toc-text">限流的几种算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">限流的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson-%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">Redisson 限流实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E7%B2%92%E5%BA%A6"><span class="toc-number">1.7.3.</span> <span class="toc-text">限流粒度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E5%88%86"><span class="toc-number">1.8.</span> <span class="toc-text">系统问题分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8C%96"><span class="toc-number">1.9.</span> <span class="toc-text">异步化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.9.1.</span> <span class="toc-text">业务流程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BC%82%E6%AD%A5%E5%8C%96%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.9.2.</span> <span class="toc-text">标准异步化的业务流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.9.3.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.9.3.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">线程池的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">自定义线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91"><span class="toc-number">1.9.4.</span> <span class="toc-text">开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">实现工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">任务执行逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%82%B9"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">优化点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%9C%9F%E8%AE%A1%E5%88%92"><span class="toc-number">1.10.</span> <span class="toc-text">第六期计划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E5%8C%96%E7%8E%B0%E7%8A%B6%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.11.</span> <span class="toc-text">分析系统化现状的不足</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.12.</span> <span class="toc-text">分布式消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.12.1.</span> <span class="toc-text">中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.12.2.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.12.3.</span> <span class="toc-text">消息队列的模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">1.12.4.</span> <span class="toc-text">为什么要用消息队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.12.5.</span> <span class="toc-text">分布式消息队列的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">1.12.5.1.</span> <span class="toc-text">应用解耦的优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">1.12.5.2.</span> <span class="toc-text">发布订阅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.12.6.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.12.7.</span> <span class="toc-text">消息队列的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B"><span class="toc-number">1.12.8.</span> <span class="toc-text">主流分布式消息队列选型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E6%8A%80%E6%9C%AF"><span class="toc-number">1.12.8.1.</span> <span class="toc-text">主流技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">1.12.8.2.</span> <span class="toc-text">技术对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98"><span class="toc-number">1.12.9.</span> <span class="toc-text">RabbitMQ 入门实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">1.12.9.1.</span> <span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.12.9.2.</span> <span class="toc-text">多消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="toc-number">1.12.9.3.</span> <span class="toc-text">消息确认</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.12.9.4.</span> <span class="toc-text">交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.12.9.5.</span> <span class="toc-text">Direct交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#topic%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.12.9.6.</span> <span class="toc-text">topic交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Headers-%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">1.12.9.7.</span> <span class="toc-text">Headers 交换机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPC"><span class="toc-number">1.12.9.8.</span> <span class="toc-text">RPC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.12.10.</span> <span class="toc-text">核心特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.12.10.1.</span> <span class="toc-text">消息过期机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.12.10.2.</span> <span class="toc-text">死信队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86"><span class="toc-number">1.12.11.</span> <span class="toc-text">RabbitMQ重点知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="toc-number">1.12.12.</span> <span class="toc-text">RabbitMQ 项目实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BI%E9%A1%B9%E7%9B%AE%E9%80%9A%E8%BF%87RabbitMQ%E6%94%B9%E9%80%A0"><span class="toc-number">1.12.13.</span> <span class="toc-text">BI项目通过RabbitMQ改造</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/JVM-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM 面试题"><img src="/img/post_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM 面试题"></a><div class="content"><a class="title" href="/2024/09/22/JVM-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM 面试题">JVM 面试题</a><time datetime="2024-09-22T14:42:32.000Z" title="发表于 2024-09-22 22:42:32">2024-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/21/JUC-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JUC 面试题"><img src="/img/post_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC 面试题"></a><div class="content"><a class="title" href="/2024/09/21/JUC-%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JUC 面试题">JUC 面试题</a><time datetime="2024-09-21T14:02:31.000Z" title="发表于 2024-09-21 22:02:31">2024-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/06/%E9%9D%A2%E8%AF%95%E7%8B%97-interviewdog-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="面试狗 - interviewdog 项目笔记"><img src="/img/post_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试狗 - interviewdog 项目笔记"></a><div class="content"><a class="title" href="/2024/09/06/%E9%9D%A2%E8%AF%95%E7%8B%97-interviewdog-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="面试狗 - interviewdog 项目笔记">面试狗 - interviewdog 项目笔记</a><time datetime="2024-09-06T15:49:00.000Z" title="发表于 2024-09-06 23:49:00">2024-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/12/Redisson-%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/" title="Redisson 详细使用"><img src="/img/post_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redisson 详细使用"></a><div class="content"><a class="title" href="/2024/08/12/Redisson-%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/" title="Redisson 详细使用">Redisson 详细使用</a><time datetime="2024-08-12T15:06:31.000Z" title="发表于 2024-08-12 23:06:31">2024-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/29/%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%87%BA-Excel-%E7%9A%84%EF%BC%9F/" title="手摸手教你前端和后端是如何实现导出 Excel 的？"><img src="/img/post_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手摸手教你前端和后端是如何实现导出 Excel 的？"></a><div class="content"><a class="title" href="/2024/07/29/%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%87%BA-Excel-%E7%9A%84%EF%BC%9F/" title="手摸手教你前端和后端是如何实现导出 Excel 的？">手摸手教你前端和后端是如何实现导出 Excel 的？</a><time datetime="2024-07-29T14:59:29.000Z" title="发表于 2024-07-29 22:59:29">2024-07-29</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By 雪荷</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'uTxTLDSTgec4bcmjQMhzZLXJ-gzGzoHsz',
      appKey: 'Mj7im3r78jFLJCaSKJKqGj7m',
      avatar: 'monsterid',
      serverURLs: 'https://utxtldst.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, ))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>